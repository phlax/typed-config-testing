{"$schema": "http://json-schema.org/draft-04/schema#", "properties": {"name": {"type": "string", "description": "Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to."}, "tls_certificate": {"properties": {"certificate_chain": {"$ref": "#/definitions/envoy.api.v2.core.DataSource", "additionalProperties": true, "description": "The TLS certificate chain."}, "private_key": {"$ref": "#/definitions/envoy.api.v2.core.DataSource", "additionalProperties": true, "description": "The TLS private key."}, "private_key_provider": {"properties": {"provider_name": {"type": "string", "description": "Private key method provider name. The name must match a\n supported private key method provider type."}, "config": {"properties": {"fields": {"additionalProperties": {"additionalProperties": true, "type": "object"}, "type": "object", "description": "Unordered map of dynamically typed values."}}, "additionalProperties": true, "type": "object"}, "typed_config": {"properties": {"type_url": {"type": "string", "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."}, "value": {"type": "string", "description": "Must be a valid serialized protocol buffer of the above specified type."}}, "additionalProperties": true, "type": "object"}}, "additionalProperties": true, "type": "object", "description": "BoringSSL private key method provider. This is an alternative to :ref:`private_key\n <envoy_api_field_auth.TlsCertificate.private_key>` field. This can't be\n marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key\n <envoy_api_field_auth.TlsCertificate.private_key>` and\n :ref:`private_key_provider\n <envoy_api_field_auth.TlsCertificate.private_key_provider>` fields will result in an\n error."}, "password": {"$ref": "#/definitions/envoy.api.v2.core.DataSource", "additionalProperties": true, "description": "The password to decrypt the TLS private key. If this field is not set, it is assumed that the\n TLS private key is not password encrypted."}, "ocsp_staple": {"$ref": "#/definitions/envoy.api.v2.core.DataSource", "additionalProperties": true, "description": "[#not-implemented-hide:]"}, "signed_certificate_timestamp": {"items": {"$schema": "http://json-schema.org/draft-04/schema#", "$ref": "#/definitions/envoy.api.v2.core.DataSource"}, "type": "array", "description": "[#not-implemented-hide:]"}}, "additionalProperties": true, "type": "object"}, "session_ticket_keys": {"properties": {"keys": {"items": {"$schema": "http://json-schema.org/draft-04/schema#", "$ref": "#/definitions/envoy.api.v2.core.DataSource"}, "type": "array", "description": "Keys for encrypting and decrypting TLS session tickets. The\n first key in the array contains the key to encrypt all new sessions created by this context.\n All keys are candidates for decrypting received tickets. This allows for easy rotation of keys\n by, for example, putting the new key first, and the previous key second.\n\n If :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`\n is not specified, the TLS library will still support resuming sessions via tickets, but it will\n use an internally-generated and managed key, so sessions cannot be resumed across hot restarts\n or on different hosts.\n\n Each key must contain exactly 80 bytes of cryptographically-secure random data. For\n example, the output of ``openssl rand 80``.\n\n .. attention::\n\n   Using this feature has serious security considerations and risks. Improper handling of keys\n   may result in loss of secrecy in connections, even if ciphers supporting perfect forward\n   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some\n   discussion. To minimize the risk, you must:\n\n   * Keep the session ticket keys at least as secure as your TLS certificate private keys\n   * Rotate session ticket keys at least daily, and preferably hourly\n   * Always generate keys using a cryptographically-secure random data source"}}, "additionalProperties": true, "type": "object"}, "validation_context": {"properties": {"trusted_ca": {"$ref": "#/definitions/envoy.api.v2.core.DataSource", "additionalProperties": true, "description": "TLS certificate data containing certificate authority certificates to use in verifying\n a presented peer certificate (e.g. server certificate for clusters or client certificate\n for listeners). If not specified and a peer certificate is presented it will not be\n verified. By default, a client certificate is optional, unless one of the additional\n options (:ref:`require_client_certificate\n <envoy_api_field_auth.DownstreamTlsContext.require_client_certificate>`,\n :ref:`verify_certificate_spki\n <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>`,\n :ref:`verify_certificate_hash\n <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`, or\n :ref:`match_subject_alt_names\n <envoy_api_field_auth.CertificateValidationContext.match_subject_alt_names>`) is also\n specified.\n\n It can optionally contain certificate revocation lists, in which case Envoy will verify\n that the presented peer certificate has not been revoked by one of the included CRLs.\n\n See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common\n system CA locations."}, "verify_certificate_spki": {"items": {"type": "string"}, "type": "array", "description": "An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the\n SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate\n matches one of the specified values.\n\n A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate\n can be generated with the following command:\n\n .. code-block:: bash\n\n   $ openssl x509 -in path/to/client.crt -noout -pubkey\n     | openssl pkey -pubin -outform DER\n     | openssl dgst -sha256 -binary\n     | openssl enc -base64\n   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=\n\n This is the format used in HTTP Public Key Pinning.\n\n When both:\n :ref:`verify_certificate_hash\n <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and\n :ref:`verify_certificate_spki\n <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,\n a hash matching value from either of the lists will result in the certificate being accepted.\n\n .. attention::\n\n   This option is preferred over :ref:`verify_certificate_hash\n   <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>`,\n   because SPKI is tied to a private key, so it doesn't change when the certificate\n   is renewed using the same private key."}, "verify_certificate_hash": {"items": {"type": "string"}, "type": "array", "description": "An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that\n the SHA-256 of the DER-encoded presented certificate matches one of the specified values.\n\n A hex-encoded SHA-256 of the certificate can be generated with the following command:\n\n .. code-block:: bash\n\n   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d\" \" -f2\n   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a\n\n A long hex-encoded and colon-separated SHA-256 (a.k.a. \"fingerprint\") of the certificate\n can be generated with the following command:\n\n .. code-block:: bash\n\n   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d\"=\" -f2\n   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A\n\n Both of those formats are acceptable.\n\n When both:\n :ref:`verify_certificate_hash\n <envoy_api_field_auth.CertificateValidationContext.verify_certificate_hash>` and\n :ref:`verify_certificate_spki\n <envoy_api_field_auth.CertificateValidationContext.verify_certificate_spki>` are specified,\n a hash matching value from either of the lists will result in the certificate being accepted."}, "verify_subject_alt_name": {"items": {"type": "string"}, "type": "array", "description": "An optional list of Subject Alternative Names. If specified, Envoy will verify that the\n Subject Alternative Name of the presented certificate matches one of the specified values.\n\n .. attention::\n\n   Subject Alternative Names are easily spoofable and verifying only them is insecure,\n   therefore this option must be used together with :ref:`trusted_ca\n   <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`."}, "match_subject_alt_names": {"items": {"$schema": "http://json-schema.org/draft-04/schema#", "properties": {"exact": {"type": "string", "description": "The input string must match exactly the string specified here.\n\n Examples:\n\n * *abc* only matches the value *abc*."}, "prefix": {"type": "string", "description": "The input string must have the prefix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *abc.xyz*"}, "suffix": {"type": "string", "description": "The input string must have the suffix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *xyz.abc*"}, "regex": {"type": "string", "description": "The input string must match the regular expression specified here.\n The regex grammar is defined `here\n <https://en.cppreference.com/w/cpp/regex/ecmascript>`_.\n\n Examples:\n\n * The regex ``\\d{3}`` matches the value *123*\n * The regex ``\\d{3}`` does not match the value *1234*\n * The regex ``\\d{3}`` does not match the value *123.456*\n\n .. attention::\n   This field has been deprecated in favor of `safe_regex` as it is not safe for use with\n   untrusted input in all cases."}, "safe_regex": {"properties": {"google_re2": {"properties": {"max_program_size": {"additionalProperties": true, "type": "integer", "description": "This field controls the RE2 \"program size\" which is a rough estimate of how complex a\n compiled regex is to evaluate. A regex that has a program size greater than the configured\n value will fail to compile. In this case, the configured max program size can be increased\n or the regex can be simplified. If not specified, the default is 100.\n\n This field is deprecated; regexp validation should be performed on the management server\n instead of being done by each individual client."}}, "additionalProperties": true, "type": "object", "description": "Google's RE2 regex engine."}, "regex": {"type": "string", "description": "The regex match string. The string must be supported by the configured engine."}}, "additionalProperties": true, "type": "object", "description": "The input string must match the regular expression specified here."}, "ignore_case": {"type": "boolean", "description": "If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no\n effect for the safe_regex match.\n For example, the matcher *data* will match both input string *Data* and *data* if set to true."}}, "additionalProperties": true, "type": "object", "description": "[#protodoc-title: String matcher]\n\nSpecifies the way to match a string.\n [#next-free-field: 7]"}, "type": "array", "description": "An optional list of Subject Alternative name matchers. Envoy will verify that the\n Subject Alternative Name of the presented certificate matches one of the specified matches.\n\n When a certificate has wildcard DNS SAN entries, to match a specific client, it should be\n configured with exact match type in the :ref:`string matcher <envoy_api_msg_type.matcher.StringMatcher>`.\n For example if the certificate has \"\\*.example.com\" as DNS SAN entry, to allow only \"api.example.com\",\n it should be configured as shown below.\n\n .. code-block:: yaml\n\n  match_subject_alt_names:\n    exact: \"api.example.com\"\n\n .. attention::\n\n   Subject Alternative Names are easily spoofable and verifying only them is insecure,\n   therefore this option must be used together with :ref:`trusted_ca\n   <envoy_api_field_auth.CertificateValidationContext.trusted_ca>`."}, "require_ocsp_staple": {"additionalProperties": true, "type": "boolean", "description": "[#not-implemented-hide:] Must present a signed time-stamped OCSP response."}, "require_signed_certificate_timestamp": {"additionalProperties": true, "type": "boolean", "description": "[#not-implemented-hide:] Must present signed certificate time-stamp."}, "crl": {"$ref": "#/definitions/envoy.api.v2.core.DataSource", "additionalProperties": true, "description": "An optional `certificate revocation list\n <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_\n (in PEM format). If specified, Envoy will verify that the presented peer\n certificate has not been revoked by this CRL. If this DataSource contains\n multiple CRLs, all of them will be used."}, "allow_expired_certificate": {"type": "boolean", "description": "If specified, Envoy will not reject expired certificates."}, "trust_chain_verification": {"enum": ["VERIFY_TRUST_CHAIN", 0, "ACCEPT_UNTRUSTED", 1], "oneOf": [{"type": "string"}, {"type": "integer"}], "description": "Certificate trust chain verification mode."}}, "additionalProperties": true, "type": "object"}, "generic_secret": {"properties": {"secret": {"$ref": "#/definitions/envoy.api.v2.core.DataSource", "additionalProperties": true, "description": "Secret of generic type and is available to filters."}}, "additionalProperties": true, "type": "object"}}, "additionalProperties": true, "type": "object", "description": "[#next-free-field: 6]", "definitions": {"envoy.api.v2.core.DataSource": {"$schema": "http://json-schema.org/draft-04/schema#", "properties": {"filename": {"type": "string", "description": "Local filesystem data source."}, "inline_bytes": {"type": "string", "description": "Bytes inlined in the configuration."}, "inline_string": {"type": "string", "description": "String inlined in the configuration."}}, "additionalProperties": true, "type": "object", "description": "Data source consisting of either a file or an inline value.", "id": "envoy.api.v2.core.DataSource"}}}