{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "properties": {
        "name": {
            "type": "string",
            "description": "Name (FQDN, UUID, SPKI, SHA256, etc.) by which the secret can be uniquely referred to."
        },
        "tls_certificate": {
            "properties": {
                "certificate_chain": {
                    "$ref": "envoy.config.core.v4alpha.DataSource",
                    "additionalProperties": true,
                    "description": "The TLS certificate chain.\n\n If *certificate_chain* is a filesystem path, a watch will be added to the\n parent directory for any file moves to support rotation. This currently\n only applies to dynamic secrets, when the *TlsCertificate* is delivered via\n SDS."
                },
                "private_key": {
                    "$ref": "envoy.config.core.v4alpha.DataSource",
                    "additionalProperties": true,
                    "description": "The TLS private key.\n\n If *private_key* is a filesystem path, a watch will be added to the parent\n directory for any file moves to support rotation. This currently only\n applies to dynamic secrets, when the *TlsCertificate* is delivered via SDS."
                },
                "watched_directory": {
                    "$ref": "envoy.config.core.v4alpha.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "If specified, updates of file-based *certificate_chain* and *private_key*\n sources will be triggered by this watch. The certificate/key pair will be\n read together and validated for atomic read consistency (i.e. no\n intervening modification occurred between cert/key read, verified by file\n hash comparisons). This allows explicit control over the path watched, by\n default the parent directories of the filesystem paths in\n *certificate_chain* and *private_key* are watched if this field is not\n specified. This only applies when a *TlsCertificate* is delivered by SDS\n with references to filesystem paths. See the :ref:`SDS key rotation\n \u003csds_key_rotation\u003e` documentation for further details."
                },
                "private_key_provider": {
                    "properties": {
                        "provider_name": {
                            "type": "string",
                            "description": "Private key method provider name. The name must match a\n supported private key method provider type."
                        },
                        "typed_config": {
                            "properties": {
                                "type_url": {
                                    "type": "string",
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                                },
                                "value": {
                                    "type": "string",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                                }
                            },
                            "additionalProperties": true,
                            "type": "object"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "BoringSSL private key method provider. This is an alternative to :ref:`private_key\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.TlsCertificate.private_key\u003e` field. This can't be\n marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.TlsCertificate.private_key\u003e` and\n :ref:`private_key_provider\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.TlsCertificate.private_key_provider\u003e` fields will result in an\n error."
                },
                "password": {
                    "$ref": "envoy.config.core.v4alpha.DataSource",
                    "additionalProperties": true,
                    "description": "The password to decrypt the TLS private key. If this field is not set, it is assumed that the\n TLS private key is not password encrypted."
                },
                "ocsp_staple": {
                    "$ref": "envoy.config.core.v4alpha.DataSource",
                    "additionalProperties": true,
                    "description": "The OCSP response to be stapled with this certificate during the handshake.\n The response must be DER-encoded and may only be  provided via ``filename`` or\n ``inline_bytes``. The response may pertain to only one certificate."
                },
                "signed_certificate_timestamp": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "$ref": "envoy.config.core.v4alpha.DataSource"
                    },
                    "type": "array",
                    "description": "[#not-implemented-hide:]"
                }
            },
            "additionalProperties": true,
            "type": "object"
        },
        "session_ticket_keys": {
            "properties": {
                "keys": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "$ref": "envoy.config.core.v4alpha.DataSource"
                    },
                    "type": "array",
                    "description": "Keys for encrypting and decrypting TLS session tickets. The\n first key in the array contains the key to encrypt all new sessions created by this context.\n All keys are candidates for decrypting received tickets. This allows for easy rotation of keys\n by, for example, putting the new key first, and the previous key second.\n\n If :ref:`session_ticket_keys \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.DownstreamTlsContext.session_ticket_keys\u003e`\n is not specified, the TLS library will still support resuming sessions via tickets, but it will\n use an internally-generated and managed key, so sessions cannot be resumed across hot restarts\n or on different hosts.\n\n Each key must contain exactly 80 bytes of cryptographically-secure random data. For\n example, the output of ``openssl rand 80``.\n\n .. attention::\n\n   Using this feature has serious security considerations and risks. Improper handling of keys\n   may result in loss of secrecy in connections, even if ciphers supporting perfect forward\n   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some\n   discussion. To minimize the risk, you must:\n\n   * Keep the session ticket keys at least as secure as your TLS certificate private keys\n   * Rotate session ticket keys at least daily, and preferably hourly\n   * Always generate keys using a cryptographically-secure random data source"
                }
            },
            "additionalProperties": true,
            "type": "object"
        },
        "validation_context": {
            "properties": {
                "trusted_ca": {
                    "$ref": "envoy.config.core.v4alpha.DataSource",
                    "additionalProperties": true,
                    "description": "TLS certificate data containing certificate authority certificates to use in verifying\n a presented peer certificate (e.g. server certificate for clusters or client certificate\n for listeners). If not specified and a peer certificate is presented it will not be\n verified. By default, a client certificate is optional, unless one of the additional\n options (:ref:`require_client_certificate\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.DownstreamTlsContext.require_client_certificate\u003e`,\n :ref:`verify_certificate_spki\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_spki\u003e`,\n :ref:`verify_certificate_hash\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_hash\u003e`, or\n :ref:`match_subject_alt_names\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.match_subject_alt_names\u003e`) is also\n specified.\n\n It can optionally contain certificate revocation lists, in which case Envoy will verify\n that the presented peer certificate has not been revoked by one of the included CRLs. Note\n that if a CRL is provided for any certificate authority in a trust chain, a CRL must be\n provided for all certificate authorities in that chain. Failure to do so will result in\n verification failure for both revoked and unrevoked certificates from that chain.\n\n See :ref:`the TLS overview \u003carch_overview_ssl_enabling_verification\u003e` for a list of common\n system CA locations.\n\n If *trusted_ca* is a filesystem path, a watch will be added to the parent\n directory for any file moves to support rotation. This currently only\n applies to dynamic secrets, when the *CertificateValidationContext* is\n delivered via SDS."
                },
                "watched_directory": {
                    "$ref": "envoy.config.core.v4alpha.WatchedDirectory",
                    "additionalProperties": true,
                    "description": "If specified, updates of a file-based *trusted_ca* source will be triggered\n by this watch. This allows explicit control over the path watched, by\n default the parent directory of the filesystem path in *trusted_ca* is\n watched if this field is not specified. This only applies when a\n *CertificateValidationContext* is delivered by SDS with references to\n filesystem paths. See the :ref:`SDS key rotation \u003csds_key_rotation\u003e`\n documentation for further details."
                },
                "verify_certificate_spki": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the\n SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate\n matches one of the specified values.\n\n A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate\n can be generated with the following command:\n\n .. code-block:: bash\n\n   $ openssl x509 -in path/to/client.crt -noout -pubkey\n     | openssl pkey -pubin -outform DER\n     | openssl dgst -sha256 -binary\n     | openssl enc -base64\n   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=\n\n This is the format used in HTTP Public Key Pinning.\n\n When both:\n :ref:`verify_certificate_hash\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_hash\u003e` and\n :ref:`verify_certificate_spki\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_spki\u003e` are specified,\n a hash matching value from either of the lists will result in the certificate being accepted.\n\n .. attention::\n\n   This option is preferred over :ref:`verify_certificate_hash\n   \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_hash\u003e`,\n   because SPKI is tied to a private key, so it doesn't change when the certificate\n   is renewed using the same private key."
                },
                "verify_certificate_hash": {
                    "items": {
                        "type": "string"
                    },
                    "type": "array",
                    "description": "An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that\n the SHA-256 of the DER-encoded presented certificate matches one of the specified values.\n\n A hex-encoded SHA-256 of the certificate can be generated with the following command:\n\n .. code-block:: bash\n\n   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d\" \" -f2\n   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a\n\n A long hex-encoded and colon-separated SHA-256 (a.k.a. \"fingerprint\") of the certificate\n can be generated with the following command:\n\n .. code-block:: bash\n\n   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d\"=\" -f2\n   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A\n\n Both of those formats are acceptable.\n\n When both:\n :ref:`verify_certificate_hash\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_hash\u003e` and\n :ref:`verify_certificate_spki\n \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.verify_certificate_spki\u003e` are specified,\n a hash matching value from either of the lists will result in the certificate being accepted."
                },
                "match_subject_alt_names": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "properties": {
                            "exact": {
                                "type": "string",
                                "description": "The input string must match exactly the string specified here.\n\n Examples:\n\n * *abc* only matches the value *abc*."
                            },
                            "prefix": {
                                "type": "string",
                                "description": "The input string must have the prefix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *abc.xyz*"
                            },
                            "suffix": {
                                "type": "string",
                                "description": "The input string must have the suffix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *xyz.abc*"
                            },
                            "safe_regex": {
                                "properties": {
                                    "google_re2": {
                                        "additionalProperties": true,
                                        "type": "object",
                                        "description": "Google's RE2 regex engine."
                                    },
                                    "regex": {
                                        "type": "string",
                                        "description": "The regex match string. The string must be supported by the configured engine."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object",
                                "description": "The input string must match the regular expression specified here."
                            },
                            "contains": {
                                "type": "string",
                                "description": "The input string must have the substring specified here.\n Note: empty contains match is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *xyz.abc.def*"
                            },
                            "ignore_case": {
                                "type": "boolean",
                                "description": "If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no\n effect for the safe_regex match.\n For example, the matcher *data* will match both input string *Data* and *data* if set to true."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "[#protodoc-title: String matcher]\n\nSpecifies the way to match a string.\n [#next-free-field: 8]"
                    },
                    "type": "array",
                    "description": "An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the\n Subject Alternative Name of the presented certificate matches one of the specified matchers.\n\n When a certificate has wildcard DNS SAN entries, to match a specific client, it should be\n configured with exact match type in the :ref:`string matcher \u003cenvoy_api_msg_type.matcher.v4alpha.StringMatcher\u003e`.\n For example if the certificate has \"\\*.example.com\" as DNS SAN entry, to allow only \"api.example.com\",\n it should be configured as shown below.\n\n .. code-block:: yaml\n\n  match_subject_alt_names:\n    exact: \"api.example.com\"\n\n .. attention::\n\n   Subject Alternative Names are easily spoofable and verifying only them is insecure,\n   therefore this option must be used together with :ref:`trusted_ca\n   \u003cenvoy_api_field_extensions.transport_sockets.tls.v4alpha.CertificateValidationContext.trusted_ca\u003e`."
                },
                "require_signed_certificate_timestamp": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "[#not-implemented-hide:] Must present signed certificate time-stamp."
                },
                "crl": {
                    "$ref": "envoy.config.core.v4alpha.DataSource",
                    "additionalProperties": true,
                    "description": "An optional `certificate revocation list\n \u003chttps://en.wikipedia.org/wiki/Certificate_revocation_list\u003e`_\n (in PEM format). If specified, Envoy will verify that the presented peer\n certificate has not been revoked by this CRL. If this DataSource contains\n multiple CRLs, all of them will be used. Note that if a CRL is provided\n for any certificate authority in a trust chain, a CRL must be provided\n for all certificate authorities in that chain. Failure to do so will\n result in verification failure for both revoked and unrevoked certificates\n from that chain."
                },
                "allow_expired_certificate": {
                    "type": "boolean",
                    "description": "If specified, Envoy will not reject expired certificates."
                },
                "trust_chain_verification": {
                    "enum": [
                        "VERIFY_TRUST_CHAIN",
                        0,
                        "ACCEPT_UNTRUSTED",
                        1
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "description": "Certificate trust chain verification mode."
                }
            },
            "additionalProperties": true,
            "type": "object"
        },
        "generic_secret": {
            "properties": {
                "secret": {
                    "$ref": "envoy.config.core.v4alpha.DataSource",
                    "additionalProperties": true,
                    "description": "Secret of generic type and is available to filters."
                }
            },
            "additionalProperties": true,
            "type": "object"
        }
    },
    "additionalProperties": true,
    "type": "object",
    "description": "[#next-free-field: 6]",
    "definitions": {
        "envoy.config.core.v4alpha.DataSource": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "filename": {
                    "type": "string",
                    "description": "Local filesystem data source."
                },
                "inline_bytes": {
                    "type": "string",
                    "description": "Bytes inlined in the configuration."
                },
                "inline_string": {
                    "type": "string",
                    "description": "String inlined in the configuration."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Data source consisting of either a file or an inline value.",
            "id": "envoy.config.core.v4alpha.DataSource"
        },
        "envoy.config.core.v4alpha.WatchedDirectory": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Directory path to watch."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "A directory that is watched for changes, e.g. by inotify on Linux. Move/rename\n events inside this directory trigger the watch.",
            "id": "envoy.config.core.v4alpha.WatchedDirectory"
        }
    }
}