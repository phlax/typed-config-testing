{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "properties": {
        "cluster": {
            "type": "string",
            "description": "Indicates the upstream cluster to which the request should be routed\n to."
        },
        "cluster_header": {
            "type": "string",
            "description": "Envoy will determine the cluster to route to by reading the value of the\n HTTP header named by cluster_header from the request headers. If the\n header is not found or the referenced cluster does not exist, Envoy will\n return a 404 response.\n\n .. attention::\n\n   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1\n   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.\n\n .. note::\n\n   If the header appears multiple times only the first value is used."
        },
        "weighted_clusters": {
            "properties": {
                "clusters": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "Name of the upstream cluster. The cluster must exist in the\n :ref:`cluster manager configuration \u003cconfig_cluster_manager\u003e`."
                            },
                            "weight": {
                                "additionalProperties": true,
                                "type": "integer",
                                "description": "An integer between 0 and :ref:`total_weight\n \u003cenvoy_api_field_config.route.v3.WeightedCluster.total_weight\u003e`. When a request matches the route,\n the choice of an upstream cluster is determined by its weight. The sum of weights across all\n entries in the clusters array must add up to the total_weight, which defaults to 100."
                            },
                            "metadata_match": {
                                "$ref": "envoy.config.core.v3.Metadata",
                                "additionalProperties": true,
                                "description": "Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in\n the upstream cluster with metadata matching what is set in this field will be considered for\n load balancing. Note that this will be merged with what's provided in\n :ref:`RouteAction.metadata_match \u003cenvoy_api_field_config.route.v3.RouteAction.metadata_match\u003e`, with\n values here taking precedence. The filter name should be specified as *envoy.lb*."
                            },
                            "request_headers_to_add": {
                                "items": {
                                    "$schema": "http://json-schema.org/draft-04/schema#",
                                    "$ref": "envoy.config.core.v3.HeaderValueOption"
                                },
                                "type": "array",
                                "description": "Specifies a list of headers to be added to requests when this cluster is selected\n through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`.\n Headers specified at this level are applied before headers from the enclosing\n :ref:`envoy_api_msg_config.route.v3.Route`, :ref:`envoy_api_msg_config.route.v3.VirtualHost`, and\n :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on\n header value syntax, see the documentation on :ref:`custom request headers\n \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                            },
                            "request_headers_to_remove": {
                                "items": {
                                    "type": "string"
                                },
                                "type": "array",
                                "description": "Specifies a list of HTTP headers that should be removed from each request when\n this cluster is selected through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`."
                            },
                            "response_headers_to_add": {
                                "items": {
                                    "$schema": "http://json-schema.org/draft-04/schema#",
                                    "$ref": "envoy.config.core.v3.HeaderValueOption"
                                },
                                "type": "array",
                                "description": "Specifies a list of headers to be added to responses when this cluster is selected\n through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`.\n Headers specified at this level are applied before headers from the enclosing\n :ref:`envoy_api_msg_config.route.v3.Route`, :ref:`envoy_api_msg_config.route.v3.VirtualHost`, and\n :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on\n header value syntax, see the documentation on :ref:`custom request headers\n \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                            },
                            "response_headers_to_remove": {
                                "items": {
                                    "type": "string"
                                },
                                "type": "array",
                                "description": "Specifies a list of headers to be removed from responses when this cluster is selected\n through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`."
                            },
                            "typed_per_filter_config": {
                                "additionalProperties": {
                                    "properties": {
                                        "type_url": {
                                            "type": "string",
                                            "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                                        },
                                        "value": {
                                            "type": "string",
                                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object"
                                },
                                "type": "object",
                                "description": "The per_filter_config field can be used to provide weighted cluster-specific\n configurations for filters. The key should match the filter name, such as\n *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter\n specific; see the :ref:`HTTP filter documentation \u003cconfig_http_filters\u003e`\n for if and how it is utilized."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "[#next-free-field: 11]"
                    },
                    "type": "array",
                    "description": "Specifies one or more upstream clusters associated with the route."
                },
                "total_weight": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the total weight across all clusters. The sum of all cluster weights must equal this\n value, which must be greater than 0. Defaults to 100."
                },
                "runtime_key_prefix": {
                    "type": "string",
                    "description": "Specifies the runtime key prefix that should be used to construct the\n runtime keys associated with each cluster. When the *runtime_key_prefix* is\n specified, the router will look for weights associated with each upstream\n cluster under the key *runtime_key_prefix* + \".\" + *cluster[i].name* where\n *cluster[i]* denotes an entry in the clusters array field. If the runtime\n key for the cluster does not exist, the value specified in the\n configuration file will be used as the default weight. See the :ref:`runtime documentation\n \u003coperations_runtime\u003e` for how key names map to the underlying implementation."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Multiple upstream clusters can be specified for a given route. The\n request is routed to one of the upstream clusters based on weights\n assigned to each cluster. See\n :ref:`traffic splitting \u003cconfig_http_conn_man_route_table_traffic_splitting_split\u003e`\n for additional documentation."
        },
        "cluster_not_found_response_code": {
            "enum": [
                "SERVICE_UNAVAILABLE",
                0,
                "NOT_FOUND",
                1
            ],
            "oneOf": [
                {
                    "type": "string"
                },
                {
                    "type": "integer"
                }
            ],
            "description": "The HTTP status code to use when configured cluster is not found.\n The default response code is 503 Service Unavailable."
        },
        "metadata_match": {
            "$ref": "envoy.config.core.v3.Metadata",
            "additionalProperties": true,
            "description": "Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints\n in the upstream cluster with metadata matching what's set in this field will be considered\n for load balancing. If using :ref:`weighted_clusters\n \u003cenvoy_api_field_config.route.v3.RouteAction.weighted_clusters\u003e`, metadata will be merged, with values\n provided there taking precedence. The filter name should be specified as *envoy.lb*."
        },
        "prefix_rewrite": {
            "type": "string",
            "description": "Indicates that during forwarding, the matched prefix (or path) should be\n swapped with this value. This option allows application URLs to be rooted\n at a different path from those exposed at the reverse proxy layer. The router filter will\n place the original path before rewrite into the :ref:`x-envoy-original-path\n \u003cconfig_http_filters_router_x-envoy-original-path\u003e` header.\n\n Only one of *prefix_rewrite* or\n :ref:`regex_rewrite \u003cenvoy_api_field_config.route.v3.RouteAction.regex_rewrite\u003e`\n may be specified.\n\n .. attention::\n\n   Pay careful attention to the use of trailing slashes in the\n   :ref:`route's match \u003cenvoy_api_field_config.route.v3.Route.match\u003e` prefix value.\n   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,\n   rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single\n   :ref:`Route \u003cenvoy_api_msg_config.route.v3.Route\u003e`, as shown by the below config entries:\n\n   .. code-block:: yaml\n\n     - match:\n         prefix: \"/prefix/\"\n       route:\n         prefix_rewrite: \"/\"\n     - match:\n         prefix: \"/prefix\"\n       route:\n         prefix_rewrite: \"/\"\n\n   Having above entries in the config, requests to */prefix* will be stripped to */*, while\n   requests to */prefix/etc* will be stripped to */etc*."
        },
        "regex_rewrite": {
            "$ref": "envoy.type.matcher.v3.RegexMatchAndSubstitute",
            "additionalProperties": true,
            "description": "Indicates that during forwarding, portions of the path that match the\n pattern should be rewritten, even allowing the substitution of capture\n groups from the pattern into the new path as specified by the rewrite\n substitution string. This is useful to allow application paths to be\n rewritten in a way that is aware of segments with variable content like\n identifiers. The router filter will place the original path as it was\n before the rewrite into the :ref:`x-envoy-original-path\n \u003cconfig_http_filters_router_x-envoy-original-path\u003e` header.\n\n Only one of :ref:`prefix_rewrite \u003cenvoy_api_field_config.route.v3.RouteAction.prefix_rewrite\u003e`\n or *regex_rewrite* may be specified.\n\n Examples using Google's `RE2 \u003chttps://github.com/google/re2\u003e`_ engine:\n\n * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution\n   string of ``\\2/instance/\\1`` would transform ``/service/foo/v1/api``\n   into ``/v1/api/instance/foo``.\n\n * The pattern ``one`` paired with a substitution string of ``two`` would\n   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.\n\n * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of\n   ``\\1two\\2`` would replace only the first occurrence of ``one``,\n   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.\n\n * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``\n   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to\n   ``/aaa/yyy/bbb``."
        },
        "host_rewrite_literal": {
            "type": "string",
            "description": "Indicates that during forwarding, the host header will be swapped with\n this value."
        },
        "auto_host_rewrite": {
            "additionalProperties": true,
            "type": "boolean",
            "description": "Indicates that during forwarding, the host header will be swapped with\n the hostname of the upstream host chosen by the cluster manager. This\n option is applicable only when the destination cluster for a route is of\n type *strict_dns* or *logical_dns*. Setting this to true with other cluster\n types has no effect."
        },
        "host_rewrite_header": {
            "type": "string",
            "description": "Indicates that during forwarding, the host header will be swapped with the content of given\n downstream or :ref:`custom \u003cconfig_http_conn_man_headers_custom_request_headers\u003e` header.\n If header value is empty, host header is left intact.\n\n .. attention::\n\n   Pay attention to the potential security implications of using this option. Provided header\n   must come from trusted source.\n\n .. note::\n\n   If the header appears multiple times only the first value is used."
        },
        "host_rewrite_path_regex": {
            "$ref": "envoy.type.matcher.v3.RegexMatchAndSubstitute",
            "additionalProperties": true,
            "description": "Indicates that during forwarding, the host header will be swapped with\n the result of the regex substitution executed on path value with query and fragment removed.\n This is useful for transitioning variable content between path segment and subdomain.\n\n For example with the following config:\n\n   .. code-block:: yaml\n\n     host_rewrite_path_regex:\n       pattern:\n         google_re2: {}\n         regex: \"^/(.+)/.+$\"\n       substitution: \\1\n\n Would rewrite the host header to `envoyproxy.io` given the path `/envoyproxy.io/some/path`."
        },
        "timeout": {
            "properties": {
                "seconds": {
                    "type": "string",
                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                },
                "nanos": {
                    "type": "integer",
                    "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Specifies the upstream timeout for the route. If not specified, the default is 15s. This\n spans between the point at which the entire downstream request (i.e. end-of-stream) has been\n processed and when the upstream response has been completely processed. A value of 0 will\n disable the route's timeout.\n\n .. note::\n\n   This timeout includes all retries. See also\n   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,\n   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the\n   :ref:`retry overview \u003carch_overview_http_routing_retry\u003e`."
        },
        "idle_timeout": {
            "properties": {
                "seconds": {
                    "type": "string",
                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                },
                "nanos": {
                    "type": "integer",
                    "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,\n although the connection manager wide :ref:`stream_idle_timeout\n \u003cenvoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout\u003e`\n will still apply. A value of 0 will completely disable the route's idle timeout, even if a\n connection manager stream idle timeout is configured.\n\n The idle timeout is distinct to :ref:`timeout\n \u003cenvoy_api_field_config.route.v3.RouteAction.timeout\u003e`, which provides an upper bound\n on the upstream response time; :ref:`idle_timeout\n \u003cenvoy_api_field_config.route.v3.RouteAction.idle_timeout\u003e` instead bounds the amount\n of time the request's stream may be idle.\n\n After header decoding, the idle timeout will apply on downstream and\n upstream request events. Each time an encode/decode event for headers or\n data is processed for the stream, the timer will be reset. If the timeout\n fires, the stream is terminated with a 408 Request Timeout error code if no\n upstream response header has been received, otherwise a stream reset\n occurs.\n\n If the :ref:`overload action \u003cconfig_overload_manager_overload_actions\u003e` \"envoy.overload_actions.reduce_timeouts\"\n is configured, this timeout is scaled according to the value for\n :ref:`HTTP_DOWNSTREAM_STREAM_IDLE \u003cenvoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_STREAM_IDLE\u003e`."
        },
        "retry_policy": {
            "properties": {
                "retry_on": {
                    "type": "string",
                    "description": "Specifies the conditions under which retry takes place. These are the same\n conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and\n :ref:`config_http_filters_router_x-envoy-retry-grpc-on`."
                },
                "num_retries": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the allowed number of retries. This parameter is optional and\n defaults to 1. These are the same conditions documented for\n :ref:`config_http_filters_router_x-envoy-max-retries`."
                },
                "per_try_timeout": {
                    "properties": {
                        "seconds": {
                            "type": "string",
                            "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                        },
                        "nanos": {
                            "type": "integer",
                            "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The\n same conditions documented for\n :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.\n\n .. note::\n\n   If left unspecified, Envoy will use the global\n   :ref:`route timeout \u003cenvoy_api_field_config.route.v3.RouteAction.timeout\u003e` for the request.\n   Consequently, when using a :ref:`5xx \u003cconfig_http_filters_router_x-envoy-retry-on\u003e` based\n   retry policy, a request that times out will not be retried as the total timeout budget\n   would have been exhausted."
                },
                "retry_priority": {
                    "properties": {
                        "name": {
                            "type": "string"
                        },
                        "typed_config": {
                            "properties": {
                                "type_url": {
                                    "type": "string",
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                                },
                                "value": {
                                    "type": "string",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                                }
                            },
                            "additionalProperties": true,
                            "type": "object"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Specifies an implementation of a RetryPriority which is used to determine the\n distribution of load across priorities used for retries. Refer to\n :ref:`retry plugin configuration \u003carch_overview_http_retry_plugins\u003e` for more details."
                },
                "retry_host_predicate": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "properties": {
                            "name": {
                                "type": "string"
                            },
                            "typed_config": {
                                "properties": {
                                    "type_url": {
                                        "type": "string",
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                                    },
                                    "value": {
                                        "type": "string",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "array",
                    "description": "Specifies a collection of RetryHostPredicates that will be consulted when selecting a host\n for retries. If any of the predicates reject the host, host selection will be reattempted.\n Refer to :ref:`retry plugin configuration \u003carch_overview_http_retry_plugins\u003e` for more\n details."
                },
                "host_selection_retry_max_attempts": {
                    "type": "string",
                    "description": "The maximum number of times host selection will be reattempted before giving up, at which\n point the host that was last selected will be routed to. If unspecified, this will default to\n retrying once."
                },
                "retriable_status_codes": {
                    "items": {
                        "type": "integer"
                    },
                    "type": "array",
                    "description": "HTTP status codes that should trigger a retry in addition to those specified by retry_on."
                },
                "retry_back_off": {
                    "properties": {
                        "base_interval": {
                            "properties": {
                                "seconds": {
                                    "type": "string",
                                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                                },
                                "nanos": {
                                    "type": "integer",
                                    "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                                }
                            },
                            "additionalProperties": true,
                            "type": "object",
                            "description": "Specifies the base interval between retries. This parameter is required and must be greater\n than zero. Values less than 1 ms are rounded up to 1 ms.\n See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's\n back-off algorithm."
                        },
                        "max_interval": {
                            "properties": {
                                "seconds": {
                                    "type": "string",
                                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                                },
                                "nanos": {
                                    "type": "integer",
                                    "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                                }
                            },
                            "additionalProperties": true,
                            "type": "object",
                            "description": "Specifies the maximum interval between retries. This parameter is optional, but must be\n greater than or equal to the `base_interval` if set. The default is 10 times the\n `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion\n of Envoy's back-off algorithm."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Specifies parameters that control exponential retry back off. This parameter is optional, in which case the\n default base interval is 25 milliseconds or, if set, the current value of the\n `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times\n the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`\n describes Envoy's back-off algorithm."
                },
                "rate_limited_retry_back_off": {
                    "properties": {
                        "reset_headers": {
                            "items": {
                                "$schema": "http://json-schema.org/draft-04/schema#",
                                "properties": {
                                    "name": {
                                        "type": "string",
                                        "description": "The name of the reset header.\n\n .. note::\n\n   If the header appears multiple times only the first value is used."
                                    },
                                    "format": {
                                        "enum": [
                                            "SECONDS",
                                            0,
                                            "UNIX_TIMESTAMP",
                                            1
                                        ],
                                        "oneOf": [
                                            {
                                                "type": "string"
                                            },
                                            {
                                                "type": "integer"
                                            }
                                        ],
                                        "description": "The format of the reset header."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object"
                            },
                            "type": "array",
                            "description": "Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``)\n to match against the response. Headers are tried in order, and matched case\n insensitive. The first header to be parsed successfully is used. If no headers\n match the default exponential back-off is used instead."
                        },
                        "max_interval": {
                            "properties": {
                                "seconds": {
                                    "type": "string",
                                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                                },
                                "nanos": {
                                    "type": "integer",
                                    "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                                }
                            },
                            "additionalProperties": true,
                            "type": "object",
                            "description": "Specifies the maximum back off interval that Envoy will allow. If a reset\n header contains an interval longer than this then it will be discarded and\n the next header will be tried. Defaults to 300 seconds."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Specifies parameters that control a retry back-off strategy that is used\n when the request is rate limited by the upstream server. The server may\n return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to\n provide feedback to the client on how long to wait before retrying. If\n configured, this back-off strategy will be used instead of the\n default exponential back off strategy (configured using `retry_back_off`)\n whenever a response includes the matching headers."
                },
                "retriable_headers": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "$ref": "envoy.config.route.v3.HeaderMatcher"
                    },
                    "type": "array",
                    "description": "HTTP response headers that trigger a retry if present in the response. A retry will be\n triggered if any of the header matches match the upstream response headers.\n The field is only consulted if 'retriable-headers' retry policy is active."
                },
                "retriable_request_headers": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "$ref": "envoy.config.route.v3.HeaderMatcher"
                    },
                    "type": "array",
                    "description": "HTTP headers which must be present in the request for retries to be attempted."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Indicates that the route has a retry policy. Note that if this is set,\n it'll take precedence over the virtual host level retry policy entirely\n (e.g.: policies are not merged, most internal one becomes the enforced policy)."
        },
        "retry_policy_typed_config": {
            "properties": {
                "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                },
                "value": {
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "[#not-implemented-hide:]\n Specifies the configuration for retry policy extension. Note that if this is set, it'll take\n precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,\n most internal one becomes the enforced policy). :ref:`Retry policy \u003cenvoy_api_field_config.route.v3.VirtualHost.retry_policy\u003e`\n should not be set if this field is used."
        },
        "request_mirror_policies": {
            "items": {
                "$schema": "http://json-schema.org/draft-04/schema#",
                "properties": {
                    "cluster": {
                        "type": "string",
                        "description": "Specifies the cluster that requests will be mirrored to. The cluster must\n exist in the cluster manager configuration."
                    },
                    "runtime_fraction": {
                        "$ref": "envoy.config.core.v3.RuntimeFractionalPercent",
                        "additionalProperties": true,
                        "description": "If not specified, all requests to the target cluster will be mirrored.\n\n If specified, this field takes precedence over the `runtime_key` field and requests must also\n fall under the percentage of matches indicated by this field.\n\n For some fraction N/D, a random number in the range [0,D) is selected. If the\n number is \u003c= the value of the numerator N, or if the key is not present, the default\n value, the request will be mirrored."
                    },
                    "trace_sampled": {
                        "additionalProperties": true,
                        "type": "boolean",
                        "description": "Determines if the trace span should be sampled. Defaults to true."
                    }
                },
                "additionalProperties": true,
                "type": "object",
                "description": "The router is capable of shadowing traffic from one cluster to another. The current\n implementation is \"fire and forget,\" meaning Envoy will not wait for the shadow cluster to\n respond before returning the response from the primary cluster. All normal statistics are\n collected for the shadow cluster making this feature useful for testing.\n\n During shadowing, the host/authority header is altered such that *-shadow* is appended. This is\n useful for logging. For example, *cluster1* becomes *cluster1-shadow*.\n\n .. note::\n\n   Shadowing will not be triggered if the primary cluster does not exist."
            },
            "type": "array",
            "description": "Indicates that the route has request mirroring policies."
        },
        "priority": {
            "enum": [
                "DEFAULT",
                0,
                "HIGH",
                1
            ],
            "oneOf": [
                {
                    "type": "string"
                },
                {
                    "type": "integer"
                }
            ],
            "description": "Optionally specifies the :ref:`routing priority \u003carch_overview_http_routing_priority\u003e`."
        },
        "rate_limits": {
            "items": {
                "$schema": "http://json-schema.org/draft-04/schema#",
                "properties": {
                    "stage": {
                        "additionalProperties": true,
                        "type": "integer",
                        "description": "Refers to the stage set in the filter. The rate limit configuration only\n applies to filters with the same stage number. The default stage number is\n 0.\n\n .. note::\n\n   The filter supports a range of 0 - 10 inclusively for stage numbers."
                    },
                    "disable_key": {
                        "type": "string",
                        "description": "The key to be set in runtime to disable this rate limit configuration."
                    },
                    "actions": {
                        "items": {
                            "$schema": "http://json-schema.org/draft-04/schema#",
                            "properties": {
                                "source_cluster": {
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on source cluster."
                                },
                                "destination_cluster": {
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on destination cluster."
                                },
                                "request_headers": {
                                    "properties": {
                                        "header_name": {
                                            "type": "string",
                                            "description": "The header name to be queried from the request headers. The header’s\n value is used to populate the value of the descriptor entry for the\n descriptor_key."
                                        },
                                        "descriptor_key": {
                                            "type": "string",
                                            "description": "The key to use in the descriptor entry."
                                        },
                                        "skip_if_absent": {
                                            "type": "boolean",
                                            "description": "If set to true, Envoy skips the descriptor while calling rate limiting service\n when header is not present in the request. By default it skips calling the\n rate limiting service if this header is not present in the request."
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on request headers."
                                },
                                "remote_address": {
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on remote address."
                                },
                                "generic_key": {
                                    "properties": {
                                        "descriptor_value": {
                                            "type": "string",
                                            "description": "The value to use in the descriptor entry."
                                        },
                                        "descriptor_key": {
                                            "type": "string",
                                            "description": "An optional key to use in the descriptor entry. If not set it defaults\n to 'generic_key' as the descriptor key."
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on a generic key."
                                },
                                "header_value_match": {
                                    "properties": {
                                        "descriptor_value": {
                                            "type": "string",
                                            "description": "The value to use in the descriptor entry."
                                        },
                                        "expect_match": {
                                            "additionalProperties": true,
                                            "type": "boolean",
                                            "description": "If set to true, the action will append a descriptor entry when the\n request matches the headers. If set to false, the action will append a\n descriptor entry when the request does not match the headers. The\n default value is true."
                                        },
                                        "headers": {
                                            "items": {
                                                "$schema": "http://json-schema.org/draft-04/schema#",
                                                "$ref": "envoy.config.route.v3.HeaderMatcher"
                                            },
                                            "type": "array",
                                            "description": "Specifies a set of headers that the rate limit action should match\n on. The action will check the request’s headers against all the\n specified headers in the config. A match will happen if all the\n headers in the config are present in the request with the same values\n (or based on presence if the value field is not in the config)."
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on the existence of request headers."
                                },
                                "dynamic_metadata": {
                                    "properties": {
                                        "descriptor_key": {
                                            "type": "string",
                                            "description": "The key to use in the descriptor entry."
                                        },
                                        "metadata_key": {
                                            "$ref": "envoy.type.metadata.v3.MetadataKey",
                                            "additionalProperties": true,
                                            "description": "Metadata struct that defines the key and path to retrieve the string value. A match will\n only happen if the value in the dynamic metadata is of type string."
                                        },
                                        "default_value": {
                                            "type": "string",
                                            "description": "An optional value to use if *metadata_key* is empty. If not set and\n no value is present under the metadata_key then no descriptor is generated."
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on dynamic metadata.\n\n .. attention::\n   This field has been deprecated in favor of the :ref:`metadata \u003cenvoy_api_field_config.route.v3.RateLimit.Action.metadata\u003e` field"
                                },
                                "metadata": {
                                    "properties": {
                                        "descriptor_key": {
                                            "type": "string",
                                            "description": "The key to use in the descriptor entry."
                                        },
                                        "metadata_key": {
                                            "$ref": "envoy.type.metadata.v3.MetadataKey",
                                            "additionalProperties": true,
                                            "description": "Metadata struct that defines the key and path to retrieve the string value. A match will\n only happen if the value in the metadata is of type string."
                                        },
                                        "default_value": {
                                            "type": "string",
                                            "description": "An optional value to use if *metadata_key* is empty. If not set and\n no value is present under the metadata_key then no descriptor is generated."
                                        },
                                        "source": {
                                            "enum": [
                                                "DYNAMIC",
                                                0,
                                                "ROUTE_ENTRY",
                                                1
                                            ],
                                            "oneOf": [
                                                {
                                                    "type": "string"
                                                },
                                                {
                                                    "type": "integer"
                                                }
                                            ],
                                            "description": "Source of metadata"
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Rate limit on metadata."
                                },
                                "extension": {
                                    "$ref": "envoy.config.core.v3.TypedExtensionConfig",
                                    "additionalProperties": true,
                                    "description": "Rate limit descriptor extension. See the rate limit descriptor extensions documentation."
                                }
                            },
                            "additionalProperties": true,
                            "type": "object",
                            "description": "[#next-free-field: 10]"
                        },
                        "type": "array",
                        "description": "A list of actions that are to be applied for this rate limit configuration.\n Order matters as the actions are processed sequentially and the descriptor\n is composed by appending descriptor entries in that sequence. If an action\n cannot append a descriptor entry, no descriptor is generated for the\n configuration. See :ref:`composing actions\n \u003cconfig_http_filters_rate_limit_composing_actions\u003e` for additional documentation."
                    },
                    "limit": {
                        "properties": {
                            "dynamic_metadata": {
                                "properties": {
                                    "metadata_key": {
                                        "$ref": "envoy.type.metadata.v3.MetadataKey",
                                        "additionalProperties": true,
                                        "description": "Metadata struct that defines the key and path to retrieve the struct value.\n The value must be a struct containing an integer \"requests_per_unit\" property\n and a \"unit\" property with a value parseable to :ref:`RateLimitUnit\n enum \u003cenvoy_api_enum_type.v3.RateLimitUnit\u003e`"
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object",
                                "description": "Limit override from dynamic metadata."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "An optional limit override to be appended to the descriptor produced by this\n rate limit configuration. If the override value is invalid or cannot be resolved\n from metadata, no override is provided. See :ref:`rate limit override\n \u003cconfig_http_filters_rate_limit_rate_limit_override\u003e` for more information."
                    }
                },
                "additionalProperties": true,
                "type": "object",
                "description": "Global rate limiting :ref:`architecture overview \u003carch_overview_global_rate_limit\u003e`.\n Also applies to Local rate limiting :ref:`using descriptors \u003cconfig_http_filters_local_rate_limit_descriptors\u003e`."
            },
            "type": "array",
            "description": "Specifies a set of rate limit configurations that could be applied to the\n route."
        },
        "include_vh_rate_limits": {
            "additionalProperties": true,
            "type": "boolean",
            "description": "Specifies if the rate limit filter should include the virtual host rate\n limits. By default, if the route configured rate limits, the virtual host\n :ref:`rate_limits \u003cenvoy_api_field_config.route.v3.VirtualHost.rate_limits\u003e` are not applied to the\n request.\n\n This field is deprecated. Please use :ref:`vh_rate_limits \u003cenvoy_v3_api_field_extensions.filters.http.ratelimit.v3.RateLimitPerRoute.vh_rate_limits\u003e`"
        },
        "hash_policy": {
            "items": {
                "$schema": "http://json-schema.org/draft-04/schema#",
                "properties": {
                    "header": {
                        "properties": {
                            "header_name": {
                                "type": "string",
                                "description": "The name of the request header that will be used to obtain the hash\n key. If the request header is not present, no hash will be produced."
                            },
                            "regex_rewrite": {
                                "$ref": "envoy.type.matcher.v3.RegexMatchAndSubstitute",
                                "additionalProperties": true,
                                "description": "If specified, the request header value will be rewritten and used\n to produce the hash key."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Header hash policy."
                    },
                    "cookie": {
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "The name of the cookie that will be used to obtain the hash key. If the\n cookie is not present and ttl below is not set, no hash will be\n produced."
                            },
                            "ttl": {
                                "properties": {
                                    "seconds": {
                                        "type": "string",
                                        "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                                    },
                                    "nanos": {
                                        "type": "integer",
                                        "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object",
                                "description": "If specified, a cookie with the TTL will be generated if the cookie is\n not present. If the TTL is present and zero, the generated cookie will\n be a session cookie."
                            },
                            "path": {
                                "type": "string",
                                "description": "The name of the path for the cookie. If no path is specified here, no path\n will be set for the cookie."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Cookie hash policy."
                    },
                    "connection_properties": {
                        "properties": {
                            "source_ip": {
                                "type": "boolean",
                                "description": "Hash on source IP address."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Connection properties hash policy."
                    },
                    "query_parameter": {
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "The name of the URL query parameter that will be used to obtain the hash\n key. If the parameter is not present, no hash will be produced. Query\n parameter names are case-sensitive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Query parameter hash policy."
                    },
                    "filter_state": {
                        "properties": {
                            "key": {
                                "type": "string",
                                "description": "The name of the Object in the per-request filterState, which is an\n Envoy::Http::Hashable object. If there is no data associated with the key,\n or the stored object is not Envoy::Http::Hashable, no hash will be produced."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Filter state hash policy."
                    },
                    "terminal": {
                        "type": "boolean",
                        "description": "The flag that short-circuits the hash computing. This field provides a\n 'fallback' style of configuration: \"if a terminal policy doesn't work,\n fallback to rest of the policy list\", it saves time when the terminal\n policy works.\n\n If true, and there is already a hash computed, ignore rest of the\n list of hash polices.\n For example, if the following hash methods are configured:\n\n  ========= ========\n  specifier terminal\n  ========= ========\n  Header A  true\n  Header B  false\n  Header C  false\n  ========= ========\n\n The generateHash process ends if policy \"header A\" generates a hash, as\n it's a terminal policy."
                    }
                },
                "additionalProperties": true,
                "type": "object",
                "description": "Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer\n \u003carch_overview_load_balancing_types\u003e`.\n [#next-free-field: 7]"
            },
            "type": "array",
            "description": "Specifies a list of hash policies to use for ring hash load balancing. Each\n hash policy is evaluated individually and the combined result is used to\n route the request. The method of combination is deterministic such that\n identical lists of hash policies will produce the same hash. Since a hash\n policy examines specific parts of a request, it can fail to produce a hash\n (i.e. if the hashed header is not present). If (and only if) all configured\n hash policies fail to generate a hash, no hash will be produced for\n the route. In this case, the behavior is the same as if no hash policies\n were specified (i.e. the ring hash load balancer will choose a random\n backend). If a hash policy has the \"terminal\" attribute set to true, and\n there is already a hash generated, the hash is returned immediately,\n ignoring the rest of the hash policy list."
        },
        "cors": {
            "properties": {
                "allow_origin_string_match": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "properties": {
                            "exact": {
                                "type": "string",
                                "description": "The input string must match exactly the string specified here.\n\n Examples:\n\n * *abc* only matches the value *abc*."
                            },
                            "prefix": {
                                "type": "string",
                                "description": "The input string must have the prefix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *abc.xyz*"
                            },
                            "suffix": {
                                "type": "string",
                                "description": "The input string must have the suffix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *xyz.abc*"
                            },
                            "safe_regex": {
                                "$ref": "envoy.type.matcher.v3.RegexMatcher",
                                "additionalProperties": true,
                                "description": "The input string must match the regular expression specified here."
                            },
                            "contains": {
                                "type": "string",
                                "description": "The input string must have the substring specified here.\n Note: empty contains match is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *xyz.abc.def*"
                            },
                            "ignore_case": {
                                "type": "boolean",
                                "description": "If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no\n effect for the safe_regex match.\n For example, the matcher *data* will match both input string *Data* and *data* if set to true."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "[#protodoc-title: String matcher]\n\nSpecifies the way to match a string.\n [#next-free-field: 8]"
                    },
                    "type": "array",
                    "description": "Specifies string patterns that match allowed origins. An origin is allowed if any of the\n string matchers match."
                },
                "allow_methods": {
                    "type": "string",
                    "description": "Specifies the content for the *access-control-allow-methods* header."
                },
                "allow_headers": {
                    "type": "string",
                    "description": "Specifies the content for the *access-control-allow-headers* header."
                },
                "expose_headers": {
                    "type": "string",
                    "description": "Specifies the content for the *access-control-expose-headers* header."
                },
                "max_age": {
                    "type": "string",
                    "description": "Specifies the content for the *access-control-max-age* header."
                },
                "allow_credentials": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Specifies whether the resource allows credentials."
                },
                "filter_enabled": {
                    "$ref": "envoy.config.core.v3.RuntimeFractionalPercent",
                    "additionalProperties": true,
                    "description": "Specifies the % of requests for which the CORS filter is enabled.\n\n If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS\n filter will be enabled for 100% of the requests.\n\n If :ref:`runtime_key \u003cenvoy_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key\u003e` is\n specified, Envoy will lookup the runtime key to get the percentage of requests to filter."
                },
                "shadow_enabled": {
                    "$ref": "envoy.config.core.v3.RuntimeFractionalPercent",
                    "additionalProperties": true,
                    "description": "Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not\n enforced.\n\n This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those\n fields have to explicitly disable the filter in order for this setting to take effect.\n\n If :ref:`runtime_key \u003cenvoy_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key\u003e` is specified,\n Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate\n and track the request's *Origin* to determine if it's valid but will not enforce any policies."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Indicates that the route has a CORS policy."
        },
        "max_grpc_timeout": {
            "properties": {
                "seconds": {
                    "type": "string",
                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                },
                "nanos": {
                    "type": "integer",
                    "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Deprecated by :ref:`grpc_timeout_header_max \u003cenvoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_max\u003e`\n If present, and the request is a gRPC request, use the\n `grpc-timeout header \u003chttps://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\u003e`_,\n or its default value (infinity) instead of\n :ref:`timeout \u003cenvoy_api_field_config.route.v3.RouteAction.timeout\u003e`, but limit the applied timeout\n to the maximum value specified here. If configured as 0, the maximum allowed timeout for\n gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used\n and gRPC requests time out like any other requests using\n :ref:`timeout \u003cenvoy_api_field_config.route.v3.RouteAction.timeout\u003e` or its default.\n This can be used to prevent unexpected upstream request timeouts due to potentially long\n time gaps between gRPC request and response in gRPC streaming mode.\n\n .. note::\n\n    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes\n    precedence over `grpc-timeout header \u003chttps://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\u003e`_, when\n    both are present. See also\n    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,\n    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the\n    :ref:`retry overview \u003carch_overview_http_routing_retry\u003e`."
        },
        "grpc_timeout_offset": {
            "properties": {
                "seconds": {
                    "type": "string",
                    "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                },
                "nanos": {
                    "type": "integer",
                    "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Deprecated by :ref:`grpc_timeout_header_offset \u003cenvoy_api_field_config.route.v3.RouteAction.MaxStreamDuration.grpc_timeout_header_offset\u003e`.\n If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting\n the provided duration from the header. This is useful in allowing Envoy to set its global\n timeout to be less than that of the deadline imposed by the calling client, which makes it more\n likely that Envoy will handle the timeout instead of having the call canceled by the client.\n The offset will only be applied if the provided grpc_timeout is greater than the offset. This\n ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning\n infinity)."
        },
        "upgrade_configs": {
            "items": {
                "$schema": "http://json-schema.org/draft-04/schema#",
                "properties": {
                    "upgrade_type": {
                        "type": "string",
                        "description": "The case-insensitive name of this upgrade, e.g. \"websocket\".\n For each upgrade type present in upgrade_configs, requests with\n Upgrade: [upgrade_type] will be proxied upstream."
                    },
                    "enabled": {
                        "additionalProperties": true,
                        "type": "boolean",
                        "description": "Determines if upgrades are available on this route. Defaults to true."
                    },
                    "connect_config": {
                        "properties": {
                            "proxy_protocol_config": {
                                "properties": {
                                    "version": {
                                        "enum": [
                                            "V1",
                                            0,
                                            "V2",
                                            1
                                        ],
                                        "oneOf": [
                                            {
                                                "type": "string"
                                            },
                                            {
                                                "type": "integer"
                                            }
                                        ],
                                        "description": "The PROXY protocol version to use. See https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt for details"
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object",
                                "description": "If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Configuration for sending data upstream as a raw data payload. This is used for\n CONNECT requests, when forwarding CONNECT payload as raw TCP.\n Note that CONNECT support is currently considered alpha in Envoy.\n [#comment:TODO(htuch): Replace the above comment with an alpha tag."
                    }
                },
                "additionalProperties": true,
                "type": "object",
                "description": "Allows enabling and disabling upgrades on a per-route basis.\n This overrides any enabled/disabled upgrade filter chain specified in the\n HttpConnectionManager\n :ref:`upgrade_configs\n \u003cenvoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs\u003e`\n but does not affect any custom filter chain specified there."
            },
            "type": "array"
        },
        "internal_redirect_policy": {
            "properties": {
                "max_internal_redirects": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "An internal redirect is not handled, unless the number of previous internal redirects that a\n downstream request has encountered is lower than this value.\n In the case where a downstream request is bounced among multiple routes by internal redirect,\n the first route that hits this threshold, or does not set :ref:`internal_redirect_policy\n \u003cenvoy_api_field_config.route.v3.RouteAction.internal_redirect_policy\u003e`\n will pass the redirect back to downstream.\n\n If not specified, at most one redirect will be followed."
                },
                "redirect_response_codes": {
                    "items": {
                        "type": "integer"
                    },
                    "type": "array",
                    "description": "Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,\n only 302 will be treated as internal redirect.\n Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored."
                },
                "predicates": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "$ref": "envoy.config.core.v3.TypedExtensionConfig"
                    },
                    "type": "array",
                    "description": "Specifies a list of predicates that are queried when an upstream response is deemed\n to trigger an internal redirect by all other criteria. Any predicate in the list can reject\n the redirect, causing the response to be proxied to downstream."
                },
                "allow_cross_scheme_redirect": {
                    "type": "boolean",
                    "description": "Allow internal redirect to follow a target URI with a different scheme than the value of\n x-forwarded-proto. The default is false."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "If present, Envoy will try to follow an upstream redirect response instead of proxying the\n response back to the downstream. An upstream redirect response is defined\n by :ref:`redirect_response_codes\n \u003cenvoy_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes\u003e`."
        },
        "internal_redirect_action": {
            "enum": [
                "PASS_THROUGH_INTERNAL_REDIRECT",
                0,
                "HANDLE_INTERNAL_REDIRECT",
                1
            ],
            "oneOf": [
                {
                    "type": "string"
                },
                {
                    "type": "integer"
                }
            ]
        },
        "max_internal_redirects": {
            "additionalProperties": true,
            "type": "integer",
            "description": "An internal redirect is handled, iff the number of previous internal redirects that a\n downstream request has encountered is lower than this value, and\n :ref:`internal_redirect_action \u003cenvoy_api_field_config.route.v3.RouteAction.internal_redirect_action\u003e`\n is set to :ref:`HANDLE_INTERNAL_REDIRECT\n \u003cenvoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT\u003e`\n In the case where a downstream request is bounced among multiple routes by internal redirect,\n the first route that hits this threshold, or has\n :ref:`internal_redirect_action \u003cenvoy_api_field_config.route.v3.RouteAction.internal_redirect_action\u003e`\n set to\n :ref:`PASS_THROUGH_INTERNAL_REDIRECT\n \u003cenvoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT\u003e`\n will pass the redirect back to downstream.\n\n If not specified, at most one redirect will be followed."
        },
        "hedge_policy": {
            "properties": {
                "initial_requests": {
                    "additionalProperties": true,
                    "type": "integer",
                    "description": "Specifies the number of initial requests that should be sent upstream.\n Must be at least 1.\n Defaults to 1.\n [#not-implemented-hide:]"
                },
                "additional_request_chance": {
                    "$ref": "envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Specifies a probability that an additional upstream request should be sent\n on top of what is specified by initial_requests.\n Defaults to 0.\n [#not-implemented-hide:]"
                },
                "hedge_on_per_try_timeout": {
                    "type": "boolean",
                    "description": "Indicates that a hedged request should be sent when the per-try timeout is hit.\n This means that a retry will be issued without resetting the original request, leaving multiple upstream requests in flight.\n The first request to complete successfully will be the one returned to the caller.\n\n * At any time, a successful response (i.e. not triggering any of the retry-on conditions) would be returned to the client.\n * Before per-try timeout, an error response (per retry-on conditions) would be retried immediately or returned ot the client\n   if there are no more retries left.\n * After per-try timeout, an error response would be discarded, as a retry in the form of a hedged request is already in progress.\n\n Note: For this to have effect, you must have a :ref:`RetryPolicy \u003cenvoy_api_msg_config.route.v3.RetryPolicy\u003e` that retries at least\n one error code and specifies a maximum number of retries.\n\n Defaults to false."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Indicates that the route has a hedge policy. Note that if this is set,\n it'll take precedence over the virtual host level hedge policy entirely\n (e.g.: policies are not merged, most internal one becomes the enforced policy)."
        },
        "max_stream_duration": {
            "properties": {
                "max_stream_duration": {
                    "properties": {
                        "seconds": {
                            "type": "string",
                            "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                        },
                        "nanos": {
                            "type": "integer",
                            "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Specifies the maximum duration allowed for streams on the route. If not specified, the value\n from the :ref:`max_stream_duration\n \u003cenvoy_api_field_config.core.v3.HttpProtocolOptions.max_stream_duration\u003e` field in\n :ref:`HttpConnectionManager.common_http_protocol_options\n \u003cenvoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.common_http_protocol_options\u003e`\n is used. If this field is set explicitly to zero, any\n HttpConnectionManager max_stream_duration timeout will be disabled for\n this route."
                },
                "grpc_timeout_header_max": {
                    "properties": {
                        "seconds": {
                            "type": "string",
                            "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                        },
                        "nanos": {
                            "type": "integer",
                            "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "If present, and the request contains a `grpc-timeout header\n \u003chttps://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md\u003e`_, use that value as the\n *max_stream_duration*, but limit the applied timeout to the maximum value specified here.\n If set to 0, the `grpc-timeout` header is used without modification."
                },
                "grpc_timeout_header_offset": {
                    "properties": {
                        "seconds": {
                            "type": "string",
                            "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                        },
                        "nanos": {
                            "type": "integer",
                            "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by\n subtracting the provided duration from the header. This is useful for allowing Envoy to set\n its global timeout to be less than that of the deadline imposed by the calling client, which\n makes it more likely that Envoy will handle the timeout instead of having the call canceled\n by the client. If, after applying the offset, the resulting timeout is zero or negative,\n the stream will timeout immediately."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Specifies the maximum stream duration for this route."
        }
    },
    "additionalProperties": true,
    "type": "object",
    "description": "[#next-free-field: 37]",
    "definitions": {
        "envoy.config.core.v3.HeaderValueOption": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "header": {
                    "properties": {
                        "key": {
                            "type": "string",
                            "description": "Header name."
                        },
                        "value": {
                            "type": "string",
                            "description": "Header value.\n\n The same :ref:`format specifier \u003cconfig_access_log_format\u003e` as used for\n :ref:`HTTP access logging \u003cconfig_access_log\u003e` applies here, however\n unknown header values are replaced with the empty string instead of `-`."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Header name/value pair that this option applies to."
                },
                "append": {
                    "additionalProperties": true,
                    "type": "boolean",
                    "description": "Should the value be appended? If true (default), the value is appended to\n existing values. Otherwise it replaces any existing values."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Header name/value pair plus option to control append behavior.",
            "id": "envoy.config.core.v3.HeaderValueOption"
        },
        "envoy.config.core.v3.Metadata": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "filter_metadata": {
                    "additionalProperties": {
                        "properties": {
                            "fields": {
                                "additionalProperties": {
                                    "additionalProperties": true,
                                    "type": "object"
                                },
                                "type": "object",
                                "description": "Unordered map of dynamically typed values."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "type": "object",
                    "description": "Key is the reverse DNS filter name, e.g. com.acme.widget. The envoy.*\n namespace is reserved for Envoy's built-in filters."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Metadata provides additional inputs to filters based on matched listeners,\n filter chains, routes and endpoints. It is structured as a map, usually from\n filter name (in reverse DNS format) to metadata specific to the filter. Metadata\n key-values for a filter are merged as connection and request handling occurs,\n with later values for the same key overriding earlier values.\n\n An example use of metadata is providing additional values to\n http_connection_manager in the envoy.http_connection_manager.access_log\n namespace.\n\n Another example use of metadata is to per service config info in cluster metadata, which may get\n consumed by multiple filters.\n\n For load balancing, Metadata provides a means to subset cluster endpoints.\n Endpoints have a Metadata object associated and routes contain a Metadata\n object to match against. There are some well defined metadata used today for\n this purpose:\n\n * ``{\"envoy.lb\": {\"canary\": \u003cbool\u003e }}`` This indicates the canary status of an\n   endpoint and is also used during header processing\n   (x-envoy-upstream-canary) and for stats purposes.\n [#next-major-version: move to type/metadata/v2]",
            "id": "envoy.config.core.v3.Metadata"
        },
        "envoy.config.core.v3.RuntimeFractionalPercent": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "default_value": {
                    "$ref": "envoy.type.v3.FractionalPercent",
                    "additionalProperties": true,
                    "description": "Default value if the runtime value's for the numerator/denominator keys are not available."
                },
                "runtime_key": {
                    "type": "string",
                    "description": "Runtime key for a YAML representation of a FractionalPercent."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Runtime derived FractionalPercent with defaults for when the numerator or denominator is not\n specified via a runtime key.\n\n .. note::\n\n   Parsing of the runtime key's data is implemented such that it may be represented as a\n   :ref:`FractionalPercent \u003cenvoy_api_msg_type.v3.FractionalPercent\u003e` proto represented as JSON/YAML\n   and may also be represented as an integer with the assumption that the value is an integral\n   percentage out of 100. For instance, a runtime key lookup returning the value \"42\" would parse\n   as a `FractionalPercent` whose numerator is 42 and denominator is HUNDRED.",
            "id": "envoy.config.core.v3.RuntimeFractionalPercent"
        },
        "envoy.config.core.v3.TypedExtensionConfig": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of an extension. This is not used to select the extension, instead\n it serves the role of an opaque identifier."
                },
                "typed_config": {
                    "properties": {
                        "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                        },
                        "value": {
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "The typed config for the extension. The type URL will be used to identify\n the extension. In the case that the type URL is *udpa.type.v1.TypedStruct*,\n the inner type URL of *TypedStruct* will be utilized. See the\n :ref:`extension configuration overview\n \u003cconfig_overview_extension_configuration\u003e` for further details."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "[#protodoc-title: Extension configuration]\n\nMessage type for extension configuration.\n [#next-major-version: revisit all existing typed_config that doesn't use this wrapper.].",
            "id": "envoy.config.core.v3.TypedExtensionConfig"
        },
        "envoy.config.route.v3.HeaderMatcher": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the header in the request."
                },
                "exact_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on the value of the header."
                },
                "safe_regex_match": {
                    "$ref": "envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "If specified, this regex string is a regular expression rule which implies the entire request\n header value must match the regex. The rule will not match if only a subsequence of the\n request header value matches the regex."
                },
                "range_match": {
                    "properties": {
                        "start": {
                            "type": "string",
                            "description": "start of the range (inclusive)"
                        },
                        "end": {
                            "type": "string",
                            "description": "end of the range (exclusive)"
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "If specified, header match will be performed based on range.\n The rule will match if the request header value is within this range.\n The entire request header value must represent an integer in base 10 notation: consisting of\n an optional plus or minus sign followed by a sequence of digits. The rule will not match if\n the header value does not represent an integer. Match will fail for empty values, floating\n point numbers or if only a subsequence of the header value is an integer.\n\n Examples:\n\n * For range [-10,0), route will match for header value -1, but not for 0, \"somestring\", 10.9,\n   \"-1somestring\""
                },
                "present_match": {
                    "type": "boolean",
                    "description": "If specified, header match will be performed based on whether the header is in the\n request."
                },
                "prefix_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on the prefix of the header value.\n Note: empty prefix is not allowed, please use present_match instead.\n\n Examples:\n\n * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*."
                },
                "suffix_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on the suffix of the header value.\n Note: empty suffix is not allowed, please use present_match instead.\n\n Examples:\n\n * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*."
                },
                "contains_match": {
                    "type": "string",
                    "description": "If specified, header match will be performed based on whether the header value contains\n the given value or not.\n Note: empty contains match is not allowed, please use present_match instead.\n\n Examples:\n\n * The value *abcd* matches the value *xyzabcdpqr*, but not for *xyzbcdpqr*."
                },
                "invert_match": {
                    "type": "boolean",
                    "description": "If specified, the match result will be inverted before checking. Defaults to false.\n\n Examples:\n\n * The regex ``\\d{3}`` does not match the value *1234*, so it will match when inverted.\n * The range [-10,0) will match the value -1, so it will not match when inverted."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": ".. attention::\n\n   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*\n   header. Thus, if attempting to match on *Host*, match on *:authority* instead.\n\n .. attention::\n\n   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both\n   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,\n\n   .. code-block:: json\n\n     {\n       \"name\": \":method\",\n       \"exact_match\": \"POST\"\n     }\n\n .. attention::\n   In the absence of any header match specifier, match will default to :ref:`present_match\n   \u003cenvoy_api_field_config.route.v3.HeaderMatcher.present_match\u003e`. i.e, a request that has the :ref:`name\n   \u003cenvoy_api_field_config.route.v3.HeaderMatcher.name\u003e` header will match, regardless of the header's\n   value.\n\n  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]\n [#next-free-field: 13]",
            "id": "envoy.config.route.v3.HeaderMatcher"
        },
        "envoy.type.matcher.v3.RegexMatchAndSubstitute": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "pattern": {
                    "$ref": "envoy.type.matcher.v3.RegexMatcher",
                    "additionalProperties": true,
                    "description": "The regular expression used to find portions of a string (hereafter called\n the \"subject string\") that should be replaced. When a new string is\n produced during the substitution operation, the new string is initially\n the same as the subject string, but then all matches in the subject string\n are replaced by the substitution string. If replacing all matches isn't\n desired, regular expression anchors can be used to ensure a single match,\n so as to replace just one occurrence of a pattern. Capture groups can be\n used in the pattern to extract portions of the subject string, and then\n referenced in the substitution string."
                },
                "substitution": {
                    "type": "string",
                    "description": "The string that should be substituted into matching portions of the\n subject string during a substitution operation to produce a new string.\n Capture groups in the pattern can be referenced in the substitution\n string. Note, however, that the syntax for referring to capture groups is\n defined by the chosen regular expression engine. Google's `RE2\n \u003chttps://github.com/google/re2\u003e`_ regular expression engine uses a\n backslash followed by the capture group number to denote a numbered\n capture group. E.g., ``\\1`` refers to capture group 1, and ``\\2`` refers\n to capture group 2."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Describes how to match a string and then produce a new string using a regular\n expression and a substitution string.",
            "id": "envoy.type.matcher.v3.RegexMatchAndSubstitute"
        },
        "envoy.type.matcher.v3.RegexMatcher": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "google_re2": {
                    "properties": {
                        "max_program_size": {
                            "additionalProperties": true,
                            "type": "integer",
                            "description": "This field controls the RE2 \"program size\" which is a rough estimate of how complex a\n compiled regex is to evaluate. A regex that has a program size greater than the configured\n value will fail to compile. In this case, the configured max program size can be increased\n or the regex can be simplified. If not specified, the default is 100.\n\n This field is deprecated; regexp validation should be performed on the management server\n instead of being done by each individual client."
                        }
                    },
                    "additionalProperties": true,
                    "type": "object",
                    "description": "Google's RE2 regex engine."
                },
                "regex": {
                    "type": "string",
                    "description": "The regex match string. The string must be supported by the configured engine."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "[#protodoc-title: Regex matcher]\n\nA regex matcher designed for safety when used with untrusted input.",
            "id": "envoy.type.matcher.v3.RegexMatcher"
        },
        "envoy.type.metadata.v3.MetadataKey": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key name of Metadata to retrieve the Struct from the metadata.\n Typically, it represents a builtin subsystem or custom extension."
                },
                "path": {
                    "items": {
                        "$schema": "http://json-schema.org/draft-04/schema#",
                        "properties": {
                            "key": {
                                "type": "string",
                                "description": "If specified, use the key to retrieve the value in a Struct."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Specifies the segment in a path to retrieve value from Metadata.\n Currently it is only supported to specify the key, i.e. field name, as one segment of a path."
                    },
                    "type": "array",
                    "description": "The path to retrieve the Value from the Struct. It can be a prefix or a full path,\n e.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example,\n which depends on the particular scenario.\n\n Note: Due to that only the key type segment is supported, the path can not specify a list\n unless the list is the last segment."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "[#protodoc-title: Metadata]\n\nMetadataKey provides a general interface using `key` and `path` to retrieve value from\n :ref:`Metadata \u003cenvoy_api_msg_config.core.v3.Metadata\u003e`.\n\n For example, for the following Metadata:\n\n .. code-block:: yaml\n\n    filter_metadata:\n      envoy.xxx:\n        prop:\n          foo: bar\n          xyz:\n            hello: envoy\n\n The following MetadataKey will retrieve a string value \"bar\" from the Metadata.\n\n .. code-block:: yaml\n\n    key: envoy.xxx\n    path:\n    - key: prop\n    - key: foo",
            "id": "envoy.type.metadata.v3.MetadataKey"
        },
        "envoy.type.v3.FractionalPercent": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "numerator": {
                    "type": "integer",
                    "description": "Specifies the numerator. Defaults to 0."
                },
                "denominator": {
                    "enum": [
                        "HUNDRED",
                        0,
                        "TEN_THOUSAND",
                        1,
                        "MILLION",
                        2
                    ],
                    "oneOf": [
                        {
                            "type": "string"
                        },
                        {
                            "type": "integer"
                        }
                    ],
                    "description": "Specifies the denominator. If the denominator specified is less than the numerator, the final\n fractional percentage is capped at 1 (100%)."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "A fractional percentage is used in cases in which for performance reasons performing floating\n point to integer conversions during randomness calculations is undesirable. The message includes\n both a numerator and denominator that together determine the final fractional value.\n\n * **Example**: 1/100 = 1%.\n * **Example**: 3/10000 = 0.03%.",
            "id": "envoy.type.v3.FractionalPercent"
        }
    }
}