{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "properties": {
        "cluster_name": {
            "type": "string"
        },
        "health_checks": {
            "items": {
                "$schema": "http://json-schema.org/draft-04/schema#",
                "properties": {
                    "timeout": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The time to wait for a health check response. If the timeout is reached the\n health check attempt will be considered a failure."
                    },
                    "interval": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The interval between health checks."
                    },
                    "initial_jitter": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "An optional jitter amount in milliseconds. If specified, Envoy will start health\n checking after for a random time in ms between 0 and initial_jitter. This only\n applies to the first health check."
                    },
                    "interval_jitter": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "An optional jitter amount in milliseconds. If specified, during every\n interval Envoy will add interval_jitter to the wait time."
                    },
                    "interval_jitter_percent": {
                        "type": "integer",
                        "description": "An optional jitter amount as a percentage of interval_ms. If specified,\n during every interval Envoy will add interval_ms *\n interval_jitter_percent / 100 to the wait time.\n\n If interval_jitter_ms and interval_jitter_percent are both set, both of\n them will be used to increase the wait time."
                    },
                    "unhealthy_threshold": {
                        "additionalProperties": true,
                        "type": "integer",
                        "description": "The number of unhealthy health checks required before a host is marked\n unhealthy. Note that for *http* health checking if a host responds with 503\n this threshold is ignored and the host is considered unhealthy immediately."
                    },
                    "healthy_threshold": {
                        "additionalProperties": true,
                        "type": "integer",
                        "description": "The number of healthy health checks required before a host is marked\n healthy. Note that during startup, only a single successful health check is\n required to mark a host healthy."
                    },
                    "alt_port": {
                        "additionalProperties": true,
                        "type": "integer",
                        "description": "[#not-implemented-hide:] Non-serving port for health checking."
                    },
                    "reuse_connection": {
                        "additionalProperties": true,
                        "type": "boolean",
                        "description": "Reuse health check connection between health checks. Default is true."
                    },
                    "http_health_check": {
                        "properties": {
                            "host": {
                                "type": "string",
                                "description": "The value of the host header in the HTTP health check request. If\n left empty (default value), the name of the cluster this health check is associated\n with will be used. The host header can be customized for a specific endpoint by setting the\n :ref:`hostname \u003cenvoy_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname\u003e` field."
                            },
                            "path": {
                                "type": "string",
                                "description": "Specifies the HTTP path that will be requested during health checking. For example\n */healthcheck*."
                            },
                            "send": {
                                "$ref": "envoy.config.core.v3.HealthCheck.Payload",
                                "additionalProperties": true,
                                "description": "[#not-implemented-hide:] HTTP specific payload."
                            },
                            "receive": {
                                "$ref": "envoy.config.core.v3.HealthCheck.Payload",
                                "additionalProperties": true,
                                "description": "[#not-implemented-hide:] HTTP specific response."
                            },
                            "request_headers_to_add": {
                                "items": {
                                    "$schema": "http://json-schema.org/draft-04/schema#",
                                    "properties": {
                                        "header": {
                                            "$ref": "envoy.config.core.v3.HeaderValue",
                                            "additionalProperties": true,
                                            "description": "Header name/value pair that this option applies to."
                                        },
                                        "append": {
                                            "additionalProperties": true,
                                            "type": "boolean",
                                            "description": "Should the value be appended? If true (default), the value is appended to\n existing values. Otherwise it replaces any existing values."
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "Header name/value pair plus option to control append behavior."
                                },
                                "type": "array",
                                "description": "Specifies a list of HTTP headers that should be added to each request that is sent to the\n health checked cluster. For more information, including details on header value syntax, see\n the documentation on :ref:`custom request headers\n \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                            },
                            "request_headers_to_remove": {
                                "items": {
                                    "type": "string"
                                },
                                "type": "array",
                                "description": "Specifies a list of HTTP headers that should be removed from each request that is sent to the\n health checked cluster."
                            },
                            "expected_statuses": {
                                "items": {
                                    "$schema": "http://json-schema.org/draft-04/schema#",
                                    "properties": {
                                        "start": {
                                            "type": "string",
                                            "description": "start of the range (inclusive)"
                                        },
                                        "end": {
                                            "type": "string",
                                            "description": "end of the range (exclusive)"
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "[#protodoc-title: Range]\n\nSpecifies the int64 start and end of the range using half-open interval semantics [start,\n end)."
                                },
                                "type": "array",
                                "description": "Specifies a list of HTTP response statuses considered healthy. If provided, replaces default\n 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open\n semantics of :ref:`Int64Range \u003cenvoy_api_msg_type.v3.Int64Range\u003e`. The start and end of each\n range are required. Only statuses in the range [100, 600) are allowed."
                            },
                            "codec_client_type": {
                                "enum": [
                                    "HTTP1",
                                    0,
                                    "HTTP2",
                                    1,
                                    "HTTP3",
                                    2
                                ],
                                "oneOf": [
                                    {
                                        "type": "string"
                                    },
                                    {
                                        "type": "integer"
                                    }
                                ],
                                "description": "Use specified application protocol for health checks."
                            },
                            "service_name_matcher": {
                                "properties": {
                                    "exact": {
                                        "type": "string",
                                        "description": "The input string must match exactly the string specified here.\n\n Examples:\n\n * *abc* only matches the value *abc*."
                                    },
                                    "prefix": {
                                        "type": "string",
                                        "description": "The input string must have the prefix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *abc.xyz*"
                                    },
                                    "suffix": {
                                        "type": "string",
                                        "description": "The input string must have the suffix specified here.\n Note: empty prefix is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *xyz.abc*"
                                    },
                                    "safe_regex": {
                                        "properties": {
                                            "google_re2": {
                                                "properties": {
                                                    "max_program_size": {
                                                        "additionalProperties": true,
                                                        "type": "integer",
                                                        "description": "This field controls the RE2 \"program size\" which is a rough estimate of how complex a\n compiled regex is to evaluate. A regex that has a program size greater than the configured\n value will fail to compile. In this case, the configured max program size can be increased\n or the regex can be simplified. If not specified, the default is 100.\n\n This field is deprecated; regexp validation should be performed on the management server\n instead of being done by each individual client."
                                                    }
                                                },
                                                "additionalProperties": true,
                                                "type": "object",
                                                "description": "Google's RE2 regex engine."
                                            },
                                            "regex": {
                                                "type": "string",
                                                "description": "The regex match string. The string must be supported by the configured engine."
                                            }
                                        },
                                        "additionalProperties": true,
                                        "type": "object",
                                        "description": "The input string must match the regular expression specified here."
                                    },
                                    "contains": {
                                        "type": "string",
                                        "description": "The input string must have the substring specified here.\n Note: empty contains match is not allowed, please use regex instead.\n\n Examples:\n\n * *abc* matches the value *xyz.abc.def*"
                                    },
                                    "ignore_case": {
                                        "type": "boolean",
                                        "description": "If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no\n effect for the safe_regex match.\n For example, the matcher *data* will match both input string *Data* and *data* if set to true."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object",
                                "description": "An optional service name parameter which is used to validate the identity of\n the health checked cluster using a :ref:`StringMatcher\n \u003cenvoy_api_msg_type.matcher.v3.StringMatcher\u003e`. See the :ref:`architecture overview\n \u003carch_overview_health_checking_identity\u003e` for more information."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "HTTP health check."
                    },
                    "tcp_health_check": {
                        "properties": {
                            "send": {
                                "$ref": "envoy.config.core.v3.HealthCheck.Payload",
                                "additionalProperties": true,
                                "description": "Empty payloads imply a connect-only health check."
                            },
                            "receive": {
                                "items": {
                                    "$schema": "http://json-schema.org/draft-04/schema#",
                                    "$ref": "envoy.config.core.v3.HealthCheck.Payload"
                                },
                                "type": "array",
                                "description": "When checking the response, “fuzzy” matching is performed such that each\n binary block must be found, and in the order specified, but not\n necessarily contiguous."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "TCP health check."
                    },
                    "grpc_health_check": {
                        "properties": {
                            "service_name": {
                                "type": "string",
                                "description": "An optional service name parameter which will be sent to gRPC service in\n `grpc.health.v1.HealthCheckRequest\n \u003chttps://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20\u003e`_.\n message. See `gRPC health-checking overview\n \u003chttps://github.com/grpc/grpc/blob/master/doc/health-checking.md\u003e`_ for more information."
                            },
                            "authority": {
                                "type": "string",
                                "description": "The value of the :authority header in the gRPC health check request. If\n left empty (default value), the name of the cluster this health check is associated\n with will be used. The authority header can be customized for a specific endpoint by setting\n the :ref:`hostname \u003cenvoy_api_field_config.endpoint.v3.Endpoint.HealthCheckConfig.hostname\u003e` field."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "gRPC health check."
                    },
                    "custom_health_check": {
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "The registered name of the custom health checker."
                            },
                            "typed_config": {
                                "properties": {
                                    "type_url": {
                                        "type": "string",
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                                    },
                                    "value": {
                                        "type": "string",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Custom health check."
                    },
                    "no_traffic_interval": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The \"no traffic interval\" is a special health check interval that is used when a cluster has\n never had traffic routed to it. This lower interval allows cluster information to be kept up to\n date, without sending a potentially large amount of active health checking traffic for no\n reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the\n standard health check interval that is defined. Note that this interval takes precedence over\n any other.\n\n The default value for \"no traffic interval\" is 60 seconds."
                    },
                    "no_traffic_healthy_interval": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The \"no traffic healthy interval\" is a special health check interval that\n is used for hosts that are currently passing active health checking\n (including new hosts) when the cluster has received no traffic.\n\n This is useful for when we want to send frequent health checks with\n `no_traffic_interval` but then revert to lower frequency `no_traffic_healthy_interval` once\n a host in the cluster is marked as healthy.\n\n Once a cluster has been used for traffic routing, Envoy will shift back to using the\n standard health check interval that is defined.\n\n If no_traffic_healthy_interval is not set, it will default to the\n no traffic interval and send that interval regardless of health state."
                    },
                    "unhealthy_interval": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The \"unhealthy interval\" is a health check interval that is used for hosts that are marked as\n unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the\n standard health check interval that is defined.\n\n The default value for \"unhealthy interval\" is the same as \"interval\"."
                    },
                    "unhealthy_edge_interval": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The \"unhealthy edge interval\" is a special health check interval that is used for the first\n health check right after a host is marked as unhealthy. For subsequent health checks\n Envoy will shift back to using either \"unhealthy interval\" if present or the standard health\n check interval that is defined.\n\n The default value for \"unhealthy edge interval\" is the same as \"unhealthy interval\"."
                    },
                    "healthy_edge_interval": {
                        "properties": {
                            "seconds": {
                                "type": "string",
                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                            },
                            "nanos": {
                                "type": "integer",
                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The \"healthy edge interval\" is a special health check interval that is used for the first\n health check right after a host is marked as healthy. For subsequent health checks\n Envoy will shift back to using the standard health check interval that is defined.\n\n The default value for \"healthy edge interval\" is the same as the default interval."
                    },
                    "event_log_path": {
                        "type": "string",
                        "description": "Specifies the path to the :ref:`health check event log \u003carch_overview_health_check_logging\u003e`.\n If empty, no event log will be written."
                    },
                    "event_service": {
                        "properties": {
                            "grpc_service": {
                                "properties": {
                                    "envoy_grpc": {
                                        "properties": {
                                            "cluster_name": {
                                                "type": "string",
                                                "description": "The name of the upstream gRPC cluster. SSL credentials will be supplied\n in the :ref:`Cluster \u003cenvoy_api_msg_config.cluster.v3.Cluster\u003e` :ref:`transport_socket\n \u003cenvoy_api_field_config.cluster.v3.Cluster.transport_socket\u003e`."
                                            },
                                            "authority": {
                                                "type": "string",
                                                "description": "The `:authority` header in the grpc request. If this field is not set, the authority header value will be `cluster_name`.\n Note that this authority does not override the SNI. The SNI is provided by the transport socket of the cluster."
                                            }
                                        },
                                        "additionalProperties": true,
                                        "type": "object",
                                        "description": "Envoy's in-built gRPC client.\n See the :ref:`gRPC services overview \u003carch_overview_grpc_services\u003e`\n documentation for discussion on gRPC client selection."
                                    },
                                    "google_grpc": {
                                        "properties": {
                                            "target_uri": {
                                                "type": "string",
                                                "description": "The target URI when using the `Google C++ gRPC client\n \u003chttps://github.com/grpc/grpc\u003e`_. SSL credentials will be supplied in\n :ref:`channel_credentials \u003cenvoy_api_field_config.core.v3.GrpcService.GoogleGrpc.channel_credentials\u003e`."
                                            },
                                            "channel_credentials": {
                                                "properties": {
                                                    "ssl_credentials": {
                                                        "properties": {
                                                            "root_certs": {
                                                                "$ref": "envoy.config.core.v3.DataSource",
                                                                "additionalProperties": true,
                                                                "description": "PEM encoded server root certificates."
                                                            },
                                                            "private_key": {
                                                                "$ref": "envoy.config.core.v3.DataSource",
                                                                "additionalProperties": true,
                                                                "description": "PEM encoded client private key."
                                                            },
                                                            "cert_chain": {
                                                                "$ref": "envoy.config.core.v3.DataSource",
                                                                "additionalProperties": true,
                                                                "description": "PEM encoded client certificate chain."
                                                            }
                                                        },
                                                        "additionalProperties": true,
                                                        "type": "object"
                                                    },
                                                    "google_default": {
                                                        "additionalProperties": true,
                                                        "type": "object",
                                                        "description": "https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61"
                                                    },
                                                    "local_credentials": {
                                                        "additionalProperties": true,
                                                        "type": "object"
                                                    }
                                                },
                                                "additionalProperties": true,
                                                "type": "object"
                                            },
                                            "call_credentials": {
                                                "items": {
                                                    "$schema": "http://json-schema.org/draft-04/schema#",
                                                    "properties": {
                                                        "access_token": {
                                                            "type": "string",
                                                            "description": "Access token credentials.\n https://grpc.io/grpc/cpp/namespacegrpc.html#ad3a80da696ffdaea943f0f858d7a360d."
                                                        },
                                                        "google_compute_engine": {
                                                            "additionalProperties": true,
                                                            "type": "object",
                                                            "description": "Google Compute Engine credentials.\n https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61"
                                                        },
                                                        "google_refresh_token": {
                                                            "type": "string",
                                                            "description": "Google refresh token credentials.\n https://grpc.io/grpc/cpp/namespacegrpc.html#a96901c997b91bc6513b08491e0dca37c."
                                                        },
                                                        "service_account_jwt_access": {
                                                            "properties": {
                                                                "json_key": {
                                                                    "type": "string"
                                                                },
                                                                "token_lifetime_seconds": {
                                                                    "type": "string"
                                                                }
                                                            },
                                                            "additionalProperties": true,
                                                            "type": "object",
                                                            "description": "Service Account JWT Access credentials.\n https://grpc.io/grpc/cpp/namespacegrpc.html#a92a9f959d6102461f66ee973d8e9d3aa."
                                                        },
                                                        "google_iam": {
                                                            "properties": {
                                                                "authorization_token": {
                                                                    "type": "string"
                                                                },
                                                                "authority_selector": {
                                                                    "type": "string"
                                                                }
                                                            },
                                                            "additionalProperties": true,
                                                            "type": "object",
                                                            "description": "Google IAM credentials.\n https://grpc.io/grpc/cpp/namespacegrpc.html#a9fc1fc101b41e680d47028166e76f9d0."
                                                        },
                                                        "from_plugin": {
                                                            "properties": {
                                                                "name": {
                                                                    "type": "string"
                                                                },
                                                                "typed_config": {
                                                                    "properties": {
                                                                        "type_url": {
                                                                            "type": "string",
                                                                            "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                                                                        },
                                                                        "value": {
                                                                            "type": "string",
                                                                            "description": "Must be a valid serialized protocol buffer of the above specified type."
                                                                        }
                                                                    },
                                                                    "additionalProperties": true,
                                                                    "type": "object"
                                                                }
                                                            },
                                                            "additionalProperties": true,
                                                            "type": "object",
                                                            "description": "Custom authenticator credentials.\n https://grpc.io/grpc/cpp/namespacegrpc.html#a823c6a4b19ffc71fb33e90154ee2ad07.\n https://grpc.io/docs/guides/auth.html#extending-grpc-to-support-other-authentication-mechanisms."
                                                        },
                                                        "sts_service": {
                                                            "properties": {
                                                                "token_exchange_service_uri": {
                                                                    "type": "string",
                                                                    "description": "URI of the token exchange service that handles token exchange requests.\n [#comment:TODO(asraa): Add URI validation when implemented. Tracked by\n https://github.com/envoyproxy/protoc-gen-validate/issues/303]"
                                                                },
                                                                "resource": {
                                                                    "type": "string",
                                                                    "description": "Location of the target service or resource where the client\n intends to use the requested security token."
                                                                },
                                                                "audience": {
                                                                    "type": "string",
                                                                    "description": "Logical name of the target service where the client intends to\n use the requested security token."
                                                                },
                                                                "scope": {
                                                                    "type": "string",
                                                                    "description": "The desired scope of the requested security token in the\n context of the service or resource where the token will be used."
                                                                },
                                                                "requested_token_type": {
                                                                    "type": "string",
                                                                    "description": "Type of the requested security token."
                                                                },
                                                                "subject_token_path": {
                                                                    "type": "string",
                                                                    "description": "The path of subject token, a security token that represents the\n identity of the party on behalf of whom the request is being made."
                                                                },
                                                                "subject_token_type": {
                                                                    "type": "string",
                                                                    "description": "Type of the subject token."
                                                                },
                                                                "actor_token_path": {
                                                                    "type": "string",
                                                                    "description": "The path of actor token, a security token that represents the identity\n of the acting party. The acting party is authorized to use the\n requested security token and act on behalf of the subject."
                                                                },
                                                                "actor_token_type": {
                                                                    "type": "string",
                                                                    "description": "Type of the actor token."
                                                                }
                                                            },
                                                            "additionalProperties": true,
                                                            "type": "object",
                                                            "description": "Custom security token service which implements OAuth 2.0 token exchange.\n https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16\n See https://github.com/grpc/grpc/pull/19587."
                                                        }
                                                    },
                                                    "additionalProperties": true,
                                                    "type": "object",
                                                    "description": "[#next-free-field: 8]"
                                                },
                                                "type": "array",
                                                "description": "A set of call credentials that can be composed with `channel credentials\n \u003chttps://grpc.io/docs/guides/auth.html#credential-types\u003e`_."
                                            },
                                            "stat_prefix": {
                                                "type": "string",
                                                "description": "The human readable prefix to use when emitting statistics for the gRPC\n service.\n\n .. csv-table::\n    :header: Name, Type, Description\n    :widths: 1, 1, 2\n\n    streams_total, Counter, Total number of streams opened\n    streams_closed_\u003cgRPC status code\u003e, Counter, Total streams closed with \u003cgRPC status code\u003e"
                                            },
                                            "credentials_factory_name": {
                                                "type": "string",
                                                "description": "The name of the Google gRPC credentials factory to use. This must have been registered with\n Envoy. If this is empty, a default credentials factory will be used that sets up channel\n credentials based on other configuration parameters."
                                            },
                                            "config": {
                                                "properties": {
                                                    "fields": {
                                                        "additionalProperties": {
                                                            "additionalProperties": true,
                                                            "type": "object"
                                                        },
                                                        "type": "object",
                                                        "description": "Unordered map of dynamically typed values."
                                                    }
                                                },
                                                "additionalProperties": true,
                                                "type": "object",
                                                "description": "Additional configuration for site-specific customizations of the Google\n gRPC library."
                                            },
                                            "per_stream_buffer_limit_bytes": {
                                                "additionalProperties": true,
                                                "type": "integer",
                                                "description": "How many bytes each stream can buffer internally.\n If not set an implementation defined default is applied (1MiB)."
                                            },
                                            "channel_args": {
                                                "properties": {
                                                    "args": {
                                                        "additionalProperties": {
                                                            "properties": {
                                                                "string_value": {
                                                                    "type": "string"
                                                                },
                                                                "int_value": {
                                                                    "type": "string"
                                                                }
                                                            },
                                                            "additionalProperties": true,
                                                            "type": "object"
                                                        },
                                                        "type": "object",
                                                        "description": "See grpc_types.h GRPC_ARG #defines for keys that work here."
                                                    }
                                                },
                                                "additionalProperties": true,
                                                "type": "object",
                                                "description": "Custom channels args."
                                            }
                                        },
                                        "additionalProperties": true,
                                        "type": "object",
                                        "description": "`Google C++ gRPC client \u003chttps://github.com/grpc/grpc\u003e`_\n See the :ref:`gRPC services overview \u003carch_overview_grpc_services\u003e`\n documentation for discussion on gRPC client selection."
                                    },
                                    "timeout": {
                                        "properties": {
                                            "seconds": {
                                                "type": "string",
                                                "description": "Signed seconds of the span of time. Must be from -315,576,000,000\n to +315,576,000,000 inclusive. Note: these bounds are computed from:\n 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years"
                                            },
                                            "nanos": {
                                                "type": "integer",
                                                "description": "Signed fractions of a second at nanosecond resolution of the span\n of time. Durations less than one second are represented with a 0\n `seconds` field and a positive or negative `nanos` field. For durations\n of one second or more, a non-zero value for the `nanos` field must be\n of the same sign as the `seconds` field. Must be from -999,999,999\n to +999,999,999 inclusive."
                                            }
                                        },
                                        "additionalProperties": true,
                                        "type": "object",
                                        "description": "The timeout for the gRPC request. This is the timeout for a specific\n request."
                                    },
                                    "initial_metadata": {
                                        "items": {
                                            "$schema": "http://json-schema.org/draft-04/schema#",
                                            "$ref": "envoy.config.core.v3.HeaderValue"
                                        },
                                        "type": "array",
                                        "description": "Additional metadata to include in streams initiated to the GrpcService. This can be used for\n scenarios in which additional ad hoc authorization headers (e.g. ``x-foo-bar: baz-key``) are to\n be injected. For more information, including details on header value syntax, see the\n documentation on :ref:`custom request headers\n \u003cconfig_http_conn_man_headers_custom_request_headers\u003e`."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object",
                                "description": "Specifies the gRPC service that hosts the event reporting service."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "[#not-implemented-hide:]\n The gRPC service for the health check event service.\n If empty, health check events won't be sent to a remote endpoint."
                    },
                    "always_log_health_check_failures": {
                        "type": "boolean",
                        "description": "If set to true, health check failure events will always be logged. If set to false, only the\n initial health check failure event will be logged.\n The default value is false."
                    },
                    "tls_options": {
                        "properties": {
                            "alpn_protocols": {
                                "items": {
                                    "type": "string"
                                },
                                "type": "array",
                                "description": "Specifies the ALPN protocols for health check connections. This is useful if the\n corresponding upstream is using ALPN-based :ref:`FilterChainMatch\n \u003cenvoy_api_msg_config.listener.v3.FilterChainMatch\u003e` along with different protocols for health checks\n versus data connections. If empty, no ALPN protocols will be set on health check connections."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "This allows overriding the cluster TLS settings, just for health check connections."
                    },
                    "transport_socket_match_criteria": {
                        "properties": {
                            "fields": {
                                "additionalProperties": {
                                    "additionalProperties": true,
                                    "type": "object"
                                },
                                "type": "object",
                                "description": "Unordered map of dynamically typed values."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Optional key/value pairs that will be used to match a transport socket from those specified in the cluster's\n :ref:`tranport socket matches \u003cenvoy_api_field_config.cluster.v3.Cluster.transport_socket_matches\u003e`.\n For example, the following match criteria\n\n .. code-block:: yaml\n\n  transport_socket_match_criteria:\n    useMTLS: true\n\n Will match the following :ref:`cluster socket match \u003cenvoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch\u003e`\n\n .. code-block:: yaml\n\n  transport_socket_matches:\n  - name: \"useMTLS\"\n    match:\n      useMTLS: true\n    transport_socket:\n      name: envoy.transport_sockets.tls\n      config: { ... } # tls socket configuration\n\n If this field is set, then for health checks it will supersede an entry of *envoy.transport_socket* in the\n :ref:`LbEndpoint.Metadata \u003cenvoy_api_field_config.endpoint.v3.LbEndpoint.metadata\u003e`.\n This allows using different transport socket capabilities for health checking versus proxying to the\n endpoint.\n\n If the key/values pairs specified do not match any\n :ref:`transport socket matches \u003cenvoy_api_field_config.cluster.v3.Cluster.transport_socket_matches\u003e`,\n the cluster's :ref:`transport socket \u003cenvoy_api_field_config.cluster.v3.Cluster.transport_socket\u003e`\n will be used for health check socket configuration."
                    }
                },
                "additionalProperties": true,
                "type": "object",
                "description": "[#next-free-field: 25]"
            },
            "type": "array"
        },
        "locality_endpoints": {
            "items": {
                "$schema": "http://json-schema.org/draft-04/schema#",
                "properties": {
                    "locality": {
                        "properties": {
                            "region": {
                                "type": "string",
                                "description": "Region this :ref:`zone \u003cenvoy_api_field_config.core.v3.Locality.zone\u003e` belongs to."
                            },
                            "zone": {
                                "type": "string",
                                "description": "Defines the local service zone where Envoy is running. Though optional, it\n should be set if discovery service routing is used and the discovery\n service exposes :ref:`zone data \u003cenvoy_api_field_config.endpoint.v3.LocalityLbEndpoints.locality\u003e`,\n either in this message or via :option:`--service-zone`. The meaning of zone\n is context dependent, e.g. `Availability Zone (AZ)\n \u003chttps://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html\u003e`_\n on AWS, `Zone \u003chttps://cloud.google.com/compute/docs/regions-zones/\u003e`_ on\n GCP, etc."
                            },
                            "sub_zone": {
                                "type": "string",
                                "description": "When used for locality of upstream hosts, this field further splits zone\n into smaller chunks of sub-zones so they can be load balanced\n independently."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object"
                    },
                    "endpoints": {
                        "items": {
                            "$schema": "http://json-schema.org/draft-04/schema#",
                            "properties": {
                                "address": {
                                    "properties": {
                                        "socket_address": {
                                            "properties": {
                                                "protocol": {
                                                    "enum": [
                                                        "TCP",
                                                        0,
                                                        "UDP",
                                                        1
                                                    ],
                                                    "oneOf": [
                                                        {
                                                            "type": "string"
                                                        },
                                                        {
                                                            "type": "integer"
                                                        }
                                                    ]
                                                },
                                                "address": {
                                                    "type": "string",
                                                    "description": "The address for this socket. :ref:`Listeners \u003cconfig_listeners\u003e` will bind\n to the address. An empty address is not allowed. Specify ``0.0.0.0`` or ``::``\n to bind to any address. [#comment:TODO(zuercher) reinstate when implemented:\n It is possible to distinguish a Listener address via the prefix/suffix matching\n in :ref:`FilterChainMatch \u003cenvoy_api_msg_config.listener.v3.FilterChainMatch\u003e`.] When used\n within an upstream :ref:`BindConfig \u003cenvoy_api_msg_config.core.v3.BindConfig\u003e`, the address\n controls the source address of outbound connections. For :ref:`clusters\n \u003cenvoy_api_msg_config.cluster.v3.Cluster\u003e`, the cluster type determines whether the\n address must be an IP (*STATIC* or *EDS* clusters) or a hostname resolved by DNS\n (*STRICT_DNS* or *LOGICAL_DNS* clusters). Address resolution can be customized\n via :ref:`resolver_name \u003cenvoy_api_field_config.core.v3.SocketAddress.resolver_name\u003e`."
                                                },
                                                "port_value": {
                                                    "type": "integer"
                                                },
                                                "named_port": {
                                                    "type": "string",
                                                    "description": "This is only valid if :ref:`resolver_name\n \u003cenvoy_api_field_config.core.v3.SocketAddress.resolver_name\u003e` is specified below and the\n named resolver is capable of named port resolution."
                                                },
                                                "resolver_name": {
                                                    "type": "string",
                                                    "description": "The name of the custom resolver. This must have been registered with Envoy. If\n this is empty, a context dependent default applies. If the address is a concrete\n IP address, no resolution will occur. If address is a hostname this\n should be set for resolution other than DNS. Specifying a custom resolver with\n *STRICT_DNS* or *LOGICAL_DNS* will generate an error at runtime."
                                                },
                                                "ipv4_compat": {
                                                    "type": "boolean",
                                                    "description": "When binding to an IPv6 address above, this enables `IPv4 compatibility\n \u003chttps://tools.ietf.org/html/rfc3493#page-11\u003e`_. Binding to ``::`` will\n allow both IPv4 and IPv6 connections, with peer IPv4 addresses mapped into\n IPv6 space as ``::FFFF:\u003cIPv4-address\u003e``."
                                                }
                                            },
                                            "additionalProperties": true,
                                            "type": "object"
                                        },
                                        "pipe": {
                                            "properties": {
                                                "path": {
                                                    "type": "string",
                                                    "description": "Unix Domain Socket path. On Linux, paths starting with '@' will use the\n abstract namespace. The starting '@' is replaced by a null byte by Envoy.\n Paths starting with '@' will result in an error in environments other than\n Linux."
                                                },
                                                "mode": {
                                                    "type": "integer",
                                                    "description": "The mode for the Pipe. Not applicable for abstract sockets."
                                                }
                                            },
                                            "additionalProperties": true,
                                            "type": "object"
                                        },
                                        "envoy_internal_address": {
                                            "properties": {
                                                "server_listener_name": {
                                                    "type": "string",
                                                    "description": "[#not-implemented-hide:] The :ref:`listener name \u003cenvoy_api_field_config.listener.v3.Listener.name\u003e` of the destination internal listener."
                                                }
                                            },
                                            "additionalProperties": true,
                                            "type": "object",
                                            "description": "[#not-implemented-hide:]"
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "The upstream host address.\n\n .. attention::\n\n   The form of host address depends on the given cluster type. For STATIC or EDS,\n   it is expected to be a direct IP address (or something resolvable by the\n   specified :ref:`resolver \u003cenvoy_api_field_config.core.v3.SocketAddress.resolver_name\u003e`\n   in the Address). For LOGICAL or STRICT DNS, it is expected to be hostname,\n   and will be resolved via DNS."
                                },
                                "health_check_config": {
                                    "properties": {
                                        "port_value": {
                                            "type": "integer",
                                            "description": "Optional alternative health check port value.\n\n By default the health check address port of an upstream host is the same\n as the host's serving address port. This provides an alternative health\n check port. Setting this with a non-zero value allows an upstream host\n to have different health check address port."
                                        },
                                        "hostname": {
                                            "type": "string",
                                            "description": "By default, the host header for L7 health checks is controlled by cluster level configuration\n (see: :ref:`host \u003cenvoy_api_field_config.core.v3.HealthCheck.HttpHealthCheck.host\u003e` and\n :ref:`authority \u003cenvoy_api_field_config.core.v3.HealthCheck.GrpcHealthCheck.authority\u003e`). Setting this\n to a non-empty value allows overriding the cluster level configuration for a specific\n endpoint."
                                        }
                                    },
                                    "additionalProperties": true,
                                    "type": "object",
                                    "description": "The optional health check configuration is used as configuration for the\n health checker to contact the health checked host.\n\n .. attention::\n\n   This takes into effect only for upstream clusters with\n   :ref:`active health checking \u003carch_overview_health_checking\u003e` enabled."
                                },
                                "hostname": {
                                    "type": "string",
                                    "description": "The hostname associated with this endpoint. This hostname is not used for routing or address\n resolution. If provided, it will be associated with the endpoint, and can be used for features\n that require a hostname, like\n :ref:`auto_host_rewrite \u003cenvoy_api_field_config.route.v3.RouteAction.auto_host_rewrite\u003e`."
                                }
                            },
                            "additionalProperties": true,
                            "type": "object",
                            "description": "[#protodoc-title: Endpoints]\n\nUpstream host identifier."
                        },
                        "type": "array"
                    }
                },
                "additionalProperties": true,
                "type": "object"
            },
            "type": "array"
        },
        "transport_socket_matches": {
            "items": {
                "$schema": "http://json-schema.org/draft-04/schema#",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the match, used in stats generation."
                    },
                    "match": {
                        "properties": {
                            "fields": {
                                "additionalProperties": {
                                    "additionalProperties": true,
                                    "type": "object"
                                },
                                "type": "object",
                                "description": "Unordered map of dynamically typed values."
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "Optional endpoint metadata match criteria.\n The connection to the endpoint with metadata matching what is set in this field\n will use the transport socket configuration specified here.\n The endpoint's metadata entry in *envoy.transport_socket_match* is used to match\n against the values specified in this field."
                    },
                    "transport_socket": {
                        "properties": {
                            "name": {
                                "type": "string",
                                "description": "The name of the transport socket to instantiate. The name must match a supported transport\n socket implementation."
                            },
                            "typed_config": {
                                "properties": {
                                    "type_url": {
                                        "type": "string",
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\n protocol buffer message. This string must contain at least\n one \"/\" character. The last segment of the URL's path must represent\n the fully qualified name of the type (as in\n `path/google.protobuf.Duration`). The name should be in a canonical form\n (e.g., leading \".\" is not accepted).\n\n In practice, teams usually precompile into the binary all types that they\n expect it to use in the context of Any. However, for URLs which use the\n scheme `http`, `https`, or no scheme, one can optionally set up a type\n server that maps type URLs to message definitions as follows:\n\n * If no scheme is provided, `https` is assumed.\n * An HTTP GET on the URL must yield a [google.protobuf.Type][]\n   value in binary format, or produce an error.\n * Applications are allowed to cache lookup results based on the\n   URL, or have them precompiled into a binary to avoid any\n   lookup. Therefore, binary compatibility needs to be preserved\n   on changes to types. (Use versioned type names to manage\n   breaking changes.)\n\n Note: this functionality is not currently available in the official\n protobuf release, and it is not used for type URLs beginning with\n type.googleapis.com.\n\n Schemes other than `http`, `https` (or the empty scheme) might be\n used with implementation specific semantics."
                                    },
                                    "value": {
                                        "type": "string",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type."
                                    }
                                },
                                "additionalProperties": true,
                                "type": "object"
                            }
                        },
                        "additionalProperties": true,
                        "type": "object",
                        "description": "The configuration of the transport socket."
                    }
                },
                "additionalProperties": true,
                "type": "object",
                "description": "TransportSocketMatch specifies what transport socket config will be used\n when the match conditions are satisfied."
            },
            "type": "array",
            "description": "Optional map that gets filtered by :ref:`health_checks.transport_socket_match_criteria \u003cenvoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria\u003e`\n on connection when health checking. For more details, see\n :ref:`config.cluster.v3.Cluster.transport_socket_matches \u003cenvoy_api_field_config.cluster.v3.Cluster.transport_socket_matches\u003e`."
        }
    },
    "additionalProperties": true,
    "type": "object",
    "description": "The cluster name and locality is provided to Envoy for the endpoints that it\n health checks to support statistics reporting, logging and debugging by the\n Envoy instance (outside of HDS). For maximum usefulness, it should match the\n same cluster structure as that provided by EDS.",
    "definitions": {
        "envoy.config.core.v3.DataSource": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "filename": {
                    "type": "string",
                    "description": "Local filesystem data source."
                },
                "inline_bytes": {
                    "type": "string",
                    "description": "Bytes inlined in the configuration."
                },
                "inline_string": {
                    "type": "string",
                    "description": "String inlined in the configuration."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Data source consisting of either a file or an inline value.",
            "id": "envoy.config.core.v3.DataSource"
        },
        "envoy.config.core.v3.HeaderValue": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Header name."
                },
                "value": {
                    "type": "string",
                    "description": "Header value.\n\n The same :ref:`format specifier \u003cconfig_access_log_format\u003e` as used for\n :ref:`HTTP access logging \u003cconfig_access_log\u003e` applies here, however\n unknown header values are replaced with the empty string instead of `-`."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Header name/value pair.",
            "id": "envoy.config.core.v3.HeaderValue"
        },
        "envoy.config.core.v3.HealthCheck.Payload": {
            "$schema": "http://json-schema.org/draft-04/schema#",
            "properties": {
                "text": {
                    "type": "string",
                    "description": "Hex encoded payload. E.g., \"000000FF\"."
                },
                "binary": {
                    "type": "string",
                    "description": "[#not-implemented-hide:] Binary payload."
                }
            },
            "additionalProperties": true,
            "type": "object",
            "description": "Describes the encoding of the payload bytes in the payload.",
            "id": "envoy.config.core.v3.HealthCheck.Payload"
        }
    }
}